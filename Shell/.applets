#!/usr/bin/env bash

# Path: .applets
# Purpose: Applets for shell commands
# Use: Add applets to this file and they will be sourced by .zshrc

# This script adds helper functions to the shell
# It is sourced by .zshrc
# Define additional functions here

# adding use of website cheat.sh for command lookup
cheat(){
    curl "cheat.sh/$1"
}

# Show SSH Tunnel
show_ssh_tunnel(){
  ps -aux | grep -iE 'ssh\s+(-[fNL]+\s+)*-?[fNL]+'
}

# Test sudo access
sudo-test (){
  if [[ ! $(sudo -l -U "${USER}") ]]; then
    echo "[ERROR] User does not have sudo access"
    return 1
  else
    return 0
  fi
}

# Single command to update all tools including in this script
update_tools () {
  echo "== Updating Tools =="
  echo "== Updating AWS CLI =="
  aws-update
  echo "== Updating Kubectl =="
  echo "[INFO] Updating Kubectl to latest version - using set-kubectl -v <version> to set a specific version"
  set-kubectl -s
  echo "== Installing Helm =="
  helm-install
  echo "== Updating Terraform =="
  terraform-install
  echo "== Updating Ansible =="
  ansible-install
  return 0
}

# Update AWS CLI
aws-update () {
  # Check if user has sudo access using provided function and exit if not
  if ! sudo-test; then
    echo "[ERROR] Cannot update AWS CLI - user does not have sudo access"
    return 1
  fi
  # Check if the OS variable is set - should be set in .zshrc
  if [[ -z ${OS} ]]; then
    echo "[WARN] OS variable is not set"
    return 1
  fi
  # If the OS is Linux then run the Linux function
  if [[ "${OS}" == "Linux" ]]; then
    aws-update-linux
    return 0
  fi
  # If the OS is Mac then run the Mac function
  if [[ "${OS}" == "Mac" ]]; then
    aws-update-mac
    return 0
  fi
  # If the OS is not Linux or Mac then report an error - will only get here if OS is not set
  echo "[ERROR] OS not supported: OS is not Linux or Mac"
  return 1
}

# Update AWS CLI on Linux
aws-update-linux () {
  echo "Download AWS CLI"
  cd /tmp || return
  curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  echo "AWS CLI downloaded"
  echo "Unzipping"
  unzip awscliv2.zip
  echo "Unzipped"
  echo "Installing"
  sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
  # If the install fails then exit
  if [[ $? -ne 0 ]]; then
    echo "[ERROR] AWS CLI install failed"
    return 1
  fi
  echo "Installed"
  echo "Cleaning up"
  # rm -rf ./awscliv2.zip ./aws
  cd - || return
  echo "Completed"
  return 0
}

# Update AWS CLI on Mac
aws-update-mac () {
  echo "Download AWS CLI"
  cd /tmp || return
  curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
  echo "AWS CLI downloaded"
  echo "Installing"
  sudo installer -pkg ./AWSCLIV2.pkg -target /
  # If the install fails then exit
  if [[ $? -ne 0 ]]; then
    echo "[ERROR] AWS CLI install failed"
    return 1
  fi
  echo "Installed"
  echo "Cleaning up"
  rm -rf ./AWSCLIV2.pkg
  cd - || return
  echo "Completed"
  return 0
}

# Function to set a specific version of kubectl for the current shell and if it is not already installed download it
set-kubectl () {
  # Check if variables are already set and if so unset -f
  if [[ -v KUBECTL_VERSION ]]; then
    KUBECTL_VERSION=""
  fi
  if [[ -v USE_LATEST ]]; then
    USE_LATEST=""
  fi
  # Use getopts to parse the arguments
  while getopts ":hlsv:" opt; do
    case $opt in
      h) echo "Usage: set-kubectl [-v version]"
         echo "  -v version  The version of kubectl to use"
         return 0
      ;;
      l|s) # set the version of kubectl to the USE_LATEST version
         USE_LATEST=true
      ;;
      v) KUBECTL_VERSION="$OPTARG"
      ;;
      \?) echo "[ERROR] Invalid option -$OPTARG" >&2
          return 1
      ;;
      *) PARAMS="$PARAMS -$OPTARG"
      ;;
    esac
  done
  # If USE_LATEST is set to true then get the USE_LATEST version of kubectl
  if [[ "${USE_LATEST}" == "true" ]]; then
    echo "-l or -s is set"
    echo "Getting latest stable version of kubectl from https://storage.googleapis.com/kubernetes-release/release/stable.txt and ignoring any version passed"
    KUBECTL_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
    # remove the v from the version
    KUBECTL_VERSION="${KUBECTL_VERSION:1}"
    echo "Latest version of kubectl is: ${KUBECTL_VERSION}"
  fi
  # If KUBECTL_VERSION is not set then use the first argument
  if [[ -z "${KUBECTL_VERSION}" ]]; then
    KUBECTL_VERSION="${1}"
  fi
  # Check the passed value is a valid version
  if [[ ! "${KUBECTL_VERSION}" =~ ^[0-9]\.[0-9]+\.[0-9]+$ ]]; then
    echo "[WARN] Invalid version of kubectl specified: ${KUBECTL_VERSION}"
    # If version passed is missing the patch version then add it as 0
    if [[ "${KUBECTL_VERSION}" =~ ^[0-9]\.[0-9]+$ ]]; then
      echo "Adding patch version of 0 to ${KUBECTL_VERSION}"
      KUBECTL_VERSION="${KUBECTL_VERSION}.0"
    else
      return 1
    fi
  fi
  # If KUBECTL_VERSION is still not set then report an error and return
  if [[ -z "${KUBECTL_VERSION}" ]]; then
    echo "[ERROR] No version of kubectl specified"
    return 1
  fi
  # Confirm the version is set back to the user
  echo "Taking ${KUBECTL_VERSION} as the version of kubectl to use"
  # Check if kubectl is already installed and if the current version matches the version to be set
  # Using kubeclt version --client --short to get the version as it is faster than using kubectl version --short
  if command -v kubectl &> /dev/null; then
    if [[ "$(kubectl version --client --short | sed -r 's/Client Version: v([0-9]\.[0-9]+\.[0-9]+)/\1/')" == "${KUBECTL_VERSION}" ]]; then
      echo "kubectl is already installed and is the correct version"
      return 0
    fi
  fi
  # Setting the directory to download kubectl to
  KUBECTL_DIR="${HOME}/.local/bin/k8s/kubectl-${KUBECTL_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${KUBECTL_DIR}" ]]; then
    mkdir -p "${KUBECTL_DIR}"
  fi
  # Check the OS and set the download URL
  if [[ "$(uname)" == "Darwin" ]]; then
    KUBECTL_URL="https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/darwin/amd64/kubectl"
  elif [[ "$(uname)" == "Linux" ]]; then
    KUBECTL_URL="https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
  else
    echo "Unsupported OS"
    return 1
  fi
  # Check if the requested version is available in the directory and if not download it
  if [[ ! -f "${KUBECTL_DIR}/kubectl" ]]; then
    echo "Downloading kubectl-${KUBECTL_VERSION}"
    curl -s -L "${KUBECTL_URL}" -o "${KUBECTL_DIR}/kubectl"
    chmod +x "${KUBECTL_DIR}/kubectl"
  fi
  # Check that the version downloaded is available executable and if it report and error and exit
  if [[ ! -x "${KUBECTL_DIR}/kubectl" ]]; then
    echo "[ERROR] Error downloading kubectl v${KUBECTL_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "kubectl v${KUBECTL_VERSION} downloaded to ${KUBECTL_DIR}"
  # Check if the current version of kubectl is a symlink and if so remove it
  if [[ -L "$(command -v kubectl)" ]]; then
    echo "Removing symlink to kubectl"
    rm "$(command -v kubectl)"
  fi
  # If current version of kubectl is not a symlink then rename it to kubectl.old
  if command -v kubectl &> /dev/null; then
    echo "[WARN] Renaming current version of kubectl (located at $(command -v kubectl)) to kubectl.old"
    mv "$(command -v kubectl)" "$(command -v kubectl).old"
    echo "[WARN] If a permission error is reported then run the following command with sudo"
    echo "sudo mv $(command -v kubectl) $(command -v kubectl).old"
    echo "[WARN] If you wish to revert to the previous version of kubectl then run the following command:"
    echo "mv $(command -v kubectl).old $(command -v kubectl)"
  fi
  # Create a symlink to the requested version of kubectl
  echo "Creating symlink to ${KUBECTL_VERSION} located at ${KUBECTL_DIR}/kubectl"
  ln -s "${KUBECTL_DIR}/kubectl" "${HOME}/.local/bin/kubectl"
  return 0
}

helm-install () {
  # Install and update helm
  # Check if the ${OS} variable is set and if not report an error and exit
  if [[ -z "${OS}" ]]; then
    echo "[ERROR] OS variable not set"
    return 1
  fi
  # Check the latest version of helm
  HELM_VERSION="$(curl -s https://api.github.com/repos/helm/helm/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')"
  # Check if the version is set and if not report an error and exit
  if [[ -z "${HELM_VERSION}" ]]; then
    echo "[ERROR] No version of helm specified"
    return 1
  fi
    # Check if helm is already installed and if so check the version
  if command -v helm &> /dev/null; then
    if [[ "$(helm version --short | sed -r 's/v([0-9]\.[0-9]+\.[0-9]+).*/\1/')" == "${HELM_VERSION}" ]]; then
      echo "helm ${HELM_VERSION} is already installed and is the correct version"
      return 0
    fi
  fi
  # Check if the OS is Linux or Mac and if so call the relevant function
  if [[ "${OS}" == "Linux" ]]; then
    helm-linux-install "${HELM_VERSION}"
  elif [[ "${OS}" == "Mac" ]]; then
    helm-mac-install "${HELM_VERSION}"
  else
    echo "[ERROR] Unsupported OS"
    return 1
  fi
}

helm-linux-install () {
  # Install and update helm for Linux referencing: https://helm.sh/docs/intro/install/
  # Using the script mechanism to make this easier to support across distros
  # Accept a passed variable for the HELM_VERSION from the calling function
  HELM_VERSION="${1}"
  # Setting the directory to download helm to
  HELM_DIR="${HOME}/.local/bin/k8s/helm-${HELM_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${HELM_DIR}" ]]; then
    mkdir -p "${HELM_DIR}"
  fi
  # Set the working directory to the helm directory
  cd "${HELM_DIR}" || return 1
  # Check if OpenSSL is installed and if not set VERIFY_CHECKSUM to false
  if ! command -v openssl &> /dev/null; then
    VERIFY_CHECKSUM=false
    export VERIFY_CHECKSUM
  fi
  # Echo the version of helm being installed
  echo "Installing helm v${HELM_VERSION}"
  # Download the helm install script
  curl -fsSL "https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3" -o "get_helm.sh"
  # Check if the script was downloaded and if not report an error and exit
  if [[ ! -f "get_helm.sh" ]]; then
    echo "[ERROR] Error downloading helm install script"
    return 1
  fi
  # Make the script executable
  chmod 700 "get_helm.sh"
  # Run the script
  ./get_helm.sh
  # Remove the VELIFY_CHECKSUM variable
  unset VERIFY_CHECKSUM
  # Check if helm is installed and if not report an error and exit
  if ! command -v helm &> /dev/null; then
    echo "[ERROR] helm is not installed"
    return 1
  fi
  echo "helm v${HELM_VERSION} installed"
  # Cleanup downloaded script
  echo "Cleaning up downloaded script"
  rm -f "get_helm.sh"
  echo "Completed"
  # Return to the previous working directory
  cd - || return 1
}

helm-mac-install () {
  # Install and update helm for Mac referencing: https://helm.sh/docs/intro/install/
  # Accept a passed variable for the HELM_VERSION from the calling function
  HELM_VERSION="${1}"
  # Test if brew is installed and if not report an error and exit
  if ! command -v brew &> /dev/null; then
    echo "[ERROR] brew is not installed"
    return 1
  fi
  # Check if helm is already installed, if it is update it, if not install it
  if command -v helm &> /dev/null; then
    echo "Updating helm to v${HELM_VERSION}"
    brew upgrade helm
  else
    echo "Installing helm v${HELM_VERSION}"
    brew install helm
  fi
  # Check if helm is installed and if not report an error and exit
  if ! command -v helm &> /dev/null; then
    echo "[ERROR] helm is not installed"
    return 1
  fi
  echo "helm v${HELM_VERSION} installed"
}

# Update/Intstall Terraform for both Linux and mac
terraform-install () {
  if [[ -z ${OS} ]]; then
    echo "[WARN] OS variable is not set"
    return 1
  fi
  # Check the latest available version of Terraform
  TF_VERSION=$(curl -s https://checkpoint-api.hashicorp.com/v1/check/terraform | tr -d '\r' | grep -Eo '"current_version":"[0-9]+\.[0-9]+\.[0-9]+"' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
  # Check if the version is set and if not report an error
  if [[ -z ${TF_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of Terraform"
    return 1
  fi
  if [[ ${OS} == "Linux" ]]; then
    tf-linux-install "${TF_VERSION}"
    tflint-linux-install
    tfsec-linux-install
    terraform-docs-linux-install
  fi
  if [[ ${OS} == "Mac" ]]; then
    tf-mac-install "${TF_VERSION}"
    tflint-mac-install
    tfsec-mac-install
    terraform-docs-mac-install
  fi
  # If OS is not set or is not Linux or Darwin then report an error
  if [[ ${OS} != "Linux" ]] && [[ ${OS} != "Mac" ]]; then
    echo "[ERROR] OS variable is not set to Linux or Darwin"
    return 1
  fi
}

# Install Terraform for Linux
tf-linux-install () {
  # Terraform version passed from calling function
  TF_VERSION="${1}"
  # Check if Terraform is already installed and if the current version matches the version to be set
  if command -v terraform &> /dev/null; then
    if [[ "$(terraform version | sed -r 's/Terraform v([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E '[0-9]\.[0-9]+\.[0-9]+' )" == "${TF_VERSION}" ]]; then
      echo "Terraform ${TF_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "Terraform is not installed or is not the latest version.  Installing Terraform ${TF_VERSION}"
  # Setting the directory to download Terraform to
  TF_DIR="${HOME}/.local/bin/tf/terraform-${TF_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${TF_DIR}" ]]; then
    mkdir -p "${TF_DIR}"
  fi
  # Check the OS and set the download URL
  if [[ "${OS}" == "Linux" ]]; then
    TF_URL="https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip"
  else
    echo "Unsupported OS"
    return 1
  fi
  # Check if the requested version is available in the directory and if not download it
  if [[ ! -f "${TF_DIR}/terraform" ]]; then
    echo "Downloading Terraform-${TF_VERSION}"
    curl -s -L "${TF_URL}" -o "${TF_DIR}/terraform.zip"
    unzip -o "${TF_DIR}/terraform.zip" -d "${TF_DIR}"
    chmod +x "${TF_DIR}/terraform"
  fi
  # Check that the version downloaded is available executable and if it report and error and exit
  if [[ ! -x "${TF_DIR}/terraform" ]]; then
    echo "[ERROR] Error downloading Terraform v${TF_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "Terraform v${TF_VERSION} downloaded to ${TF_DIR}"
  # Check if the current version of Terraform is a symlink and if so remove it
  if [[ -L "$(command -v terraform)" ]]; then
    echo "Removing symlink to Terraform"
    rm "$(command -v terraform)"
  fi
  # If current version of Terraform is not a symlink then rename it to Terraform.old
  if command -v terraform &> /dev/null; then
    echo "[WARN] Renaming current version of Terraform (located at $(command -v terraform)) to Terraform.old"
    mv "$(command -v terraform)" "$(command -v terraform).old"
    echo "[WARN] If a permission error is reported then run the following command with sudo"
    echo "sudo mv $(command -v terraform) $(command -v terraform).old"
    echo "[WARN] If you wish to revert to the previous version of Terraform then run the following command:"
    echo "mv $(command -v terraform).old $(command -v terraform)"
  fi
  # Create a symlink to the requested version of Terraform
  echo "Creating symlink to ${TF_VERSION} located at ${TF_DIR}/terraform"
  ln -s "${TF_DIR}/terraform" "${HOME}/.local/bin/terraform"
  return 0
}

# Install Terraform for Mac
tf-mac-install () {
  # Terraform version passed from calling function
  TF_VERSION="${1}"
  # Check if Terraform is already installed and if the current version matches the version to be set
  if command -v terraform &> /dev/null; then
    if [[ "$(terraform version | sed -r 's/Terraform v([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E '[0-9]\.[0-9]+\.[0-9]+')" == "${TF_VERSION}" ]]; then
      echo "Terraform ${TF_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "Terraform is not installed or is not the correct version.  Installing Terraform v${TF_VERSION}"
  # Setting the directory to download Terraform to
  TF_DIR="${HOME}/.local/bin/tf/terraform-${TF_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${TF_DIR}" ]]; then
    mkdir -p "${TF_DIR}"
  fi
  # Check the OS and set the download URL
  if [[ "${OS}" == "Mac" ]]; then
    TF_URL="https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_darwin_amd64.zip"
  else
    echo "Unsupported OS"
    return 1
  fi
  # Check if the requested version is available in the directory and if not download it
  if [[ ! -f "${TF_DIR}/terraform" ]]; then
    echo "Downloading Terraform-${TF_VERSION}"
    curl -s -L "${TF_URL}" -o "${TF_DIR}/terraform.zip"
    unzip -o "${TF_DIR}/terraform.zip" -d "${TF_DIR}"
    chmod +x "${TF_DIR}/terraform"
  fi
  # Check that the version downloaded is available executable and if it report and error and exit
  if [[ ! -x "${TF_DIR}/terraform" ]]; then
    echo "[ERROR] Error downloading Terraform v${TF_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "Terrform v${TF_VERSION} downloaded to ${TF_DIR}"
  # Check if the current version of Terraform is a symlink and if so remove it
  if [[ -L "$(command -v terraform)" ]]; then
    echo "Removing symlink to Terraform"
    rm "$(command -v terraform)"
  fi
  # If current version of Terraform is not a symlink then rename it to Terraform.old
  if command -v terraform &> /dev/null; then
    echo "[WARN] Renaming current version of Terraform (located at $(command -v terraform)) to Terraform.old"
    mv "$(command -v terraform)" "$(command -v terraform).old"
    echo "[WARN] If a permission error is reported then run the following command with sudo"
    echo "sudo mv $(command -v terraform) $(command -v terraform).old"
    echo "[WARN] If you wish to revert to the previous version of Terraform then run the following command:"
    echo "mv $(command -v terraform).old $(command -v terraform)"
  fi
  # Create a symlink to the requested version of Terraform
  echo "Creating symlink to ${TF_VERSION} located at ${TF_DIR}/terraform"
  ln -s "${TF_DIR}/terraform" "${HOME}/.local/bin/terraform"
}

# Install TFLint for Linux
tflint-linux-install () {
  # Referring to https://github.com/terraform-linters/tflint/blob/master/README.md
  # Check the latest available version of TFLint
  TFLINT_VERSION=$(curl -s https://api.github.com/repos/terraform-linters/tflint/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TFLINT_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of TFLint"
    return 1
  fi
  # Check if TFLint is already installed and if the current version matches the version to be set
  if command -v tflint &> /dev/null; then
    if [[ "$(tflint --version | sed -r 's/TFLint version ([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E -m 1 '[0-9]\.[0-9]+\.[0-9]+')" == "${TFLINT_VERSION}" ]]; then
      echo "TFLint ${TFLINT_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "TFLint is not installed or is not the correct version.  Installing TFLint v${TFLINT_VERSION}"
  # Setting the directory to download TFLint to
  TFLINT_DIR="${HOME}/.local/bin/tflint/tflint-${TFLINT_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${TFLINT_DIR}" ]]; then
    mkdir -p "${TFLINT_DIR}"
  fi
  # Set the working directory to the TFLint directory
  cd "${TFLINT_DIR}" || return 1
  # Follow the installation instructions for Linux from the TFLint GitHub page
  echo "Downloading TFLint-${TFLINT_VERSION}"
  curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash
  # Check that the version downloaded is available executable and if it report and error and exit
  if [[ ! -x "${TFLINT_DIR}/tflint" ]]; then
    echo "[ERROR] Error downloading TFLint v${TFLINT_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "TFLint v${TFLINT_VERSION} downloaded to ${TFLINT_DIR}"
  # Check if the current version of TFLint is a symlink and if so remove it
  if [[ -L "$(command -v tflint)" ]]; then
    echo "Removing symlink to TFLint"
    rm "$(command -v tflint)"
  fi
  # If current version of TFLint is not a symlink then rename it to TFLint.old
  if command -v tflint &> /dev/null; then
    echo "[WARN] Renaming current version of TFLint (located at $(command -v tflint)) to TFLint.old"
    mv "$(command -v tflint)" "$(command -v tflint).old"
    echo "[WARN] If a permission error is reported then run the following command with sudo"
    echo "sudo mv $(command -v tflint) $(command -v tflint).old"
    echo "[WARN] If you wish to revert to the previous version of TFLint then run the following command:"
    echo "mv $(command -v tflint).old $(command -v tflint)"
  fi
  # Create a symlink to the requested version of TFLint
  echo "Creating symlink to ${TFLINT_VERSION} located at ${TFLINT_DIR}/tflint"
  ln -s "${TFLINT_DIR}/tflint" "${HOME}/.local/bin/tflint"
}

# Install TFLint for macOS
tflint-mac-install () {
  # Referring to https://github.com/terraform-linters/tflint/blob/master/README.md
  # Check the latest available version of TFLint
  TFLINT_VERSION=$(curl -s https://api.github.com/repos/terraform-linters/tflint/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TFLINT_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of TFLint"
    return 1
  fi
  # Check if TFLint is already installed and if the current version matches the version to be set
  if command -v tflint &> /dev/null; then
    if [[ "$(tflint --version | sed -r 's/TFLint version ([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E -m 1 '[0-9]\.[0-9]+\.[0-9]+')" == "${TFLINT_VERSION}" ]]; then
      echo "TFLint ${TFLINT_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "TFLint is not installed or is not the correct version.  Installing TFLint v${TFLINT_VERSION}"
  # Per https://github.com/terraform-linters/tflint/blob/master/README.md use Homebrew to install TFLint
  # Check if Homebrew is installed and if not report an error
  if ! command -v brew &> /dev/null; then
    echo "[ERROR] Homebrew is not installed.  Please install Homebrew and try again"
    return 1
  fi
  # Check if TFLint is already installed, if not install it, if it is then upgrade it
  if command -v tflint &> /dev/null; then
    echo "Upgrading TFLint to v${TFLINT_VERSION}"
    brew upgrade tflint
  else
    echo "Installing TFLint v${TFLINT_VERSION}"
    brew install tflint
  fi
  # Check if the version installed is the correct version and if not report an error
  if [[ "$(tflint --version | sed -r 's/TFLint version ([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E -m 1 '[0-9]\.[0-9]+\.[0-9]+')" != "${TFLINT_VERSION}" ]]; then
    echo "[ERROR] Error installing TFLint v${TFLINT_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "TFLint v${TFLINT_VERSION} installed"
}

# Install tfsec for Linux
tfsec-linux-install () {
  # Referring to https://aquasecurity.github.io/tfsec/v1.28.1/guides/installation/
  # Options for Linux are more limited than for macOS and either require homebrew for Linux or to use Go package management
  # Test if go/golang is not installed; if not then exit and refer user to the tfsec installation page
  if ! command -v go &> /dev/null; then
    echo "[ERROR] Automated installation of tfsec is not available for Linux.  Please install tfsec manually"
    echo "[ERROR] For more information please refer to https://aquasecurity.github.io/tfsec/v1.28.1/guides/installation/"
    return 1
  fi
  # Check the latest available version of tfsec
  TFSEC_VERSION=$(curl -s https://api.github.com/repos/aquasecurity/tfsec/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TFSEC_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of tfsec"
    return 1
  fi
  # Check if tfsec is already installed and if the current version matches the version to be set
  if command -v tfsec &> /dev/null; then
    if [[ "$(tfsec --version | sed -r 's/tfsec version ([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E -m 1 '[0-9]\.[0-9]+\.[0-9]+')" == "${TFSEC_VERSION}" ]]; then
      echo "tfsec ${TFSEC_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "tfsec is not installed or is not the correct version.  Installing tfsec v${TFSEC_VERSION}"
  # Install tfsec using Go
  echo "Installing tfsec using Go"
  go install -u github.com/aquasecurity/tfsec/cmd/tfsec@latest
  # Check if the version installed is the correct version and if not report an error
  if [[ "$(tfsec --version | sed -r 's/tfsec version ([0-9]\.[0-9]+\.[0-9]+)/\1/' | grep -E -m 1 '[0-9]\.[0-9]+\.[0-9]+')" != "${TFSEC_VERSION}" ]]; then
    echo "[ERROR] Error installing tfsec v${TFSEC_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "tfsec v${TFSEC_VERSION} installed"
}

# Install tfsec for Mac
tfsec-mac-install () {
  # Referring to https://aquasecurity.github.io/tfsec/v1.28.1/guides/installation/
  # Check the latest available version of tfsec
  TFSEC_VERSION=$(curl -s https://api.github.com/repos/aquasecurity/tfsec/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TFSEC_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of tfsec"
    return 1
  fi
  # Check if tfsec is already installed and if the current version matches the version to be set
  if command -v tfsec &> /dev/null; then
    if [[ "$(tfsec --version | sed -r 's/v([0-9]\.[0-9]+\.[0-9]+)/\1/')" == "${TFSEC_VERSION}" ]]; then
      echo "tfsec ${TFSEC_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "tfsec is not installed or is not the correct version.  Installing tfsec v${TFSEC_VERSION}"
  # Use Homebrew to install tfsec
  # Check if Homebrew is installed and if not report an error
  if ! command -v brew &> /dev/null; then
    echo "[ERROR] Homebrew is not installed.  Please install Homebrew and try again"
    return 1
  fi
  # Check if tfsec is already installed, if not install it, if it is then upgrade it
  if command -v tfsec &> /dev/null; then
    echo "Upgrading tfsec"
    brew upgrade tfsec
  else
    echo "Installing tfsec"
    brew install tfsec
  fi
  # Check if tfsec is installed and if not report an error
  if ! command -v tfsec &> /dev/null; then
    echo "[ERROR] Error installing tfsec"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "tfsec ${TFSEC_VERSION} installed"
}

# Install terraform-docs for Linux
terraform-docs-linux-install () {
  # Referring to https://github.com/terraform-docs/terraform-docs#installation
  # Options for Linux are more limited than for macOS and either require homebrew for Linux or to use Go package management
  # Test if go/golang is not installed; if not then exit and refer user to the terraform-docs installation page
  if ! command -v go &> /dev/null; then
    echo "[ERROR] Automated installation of terraform-docs is not available for Linux.  Please install terraform-docs manually"
    echo "[ERROR] For more information please refer to https://github.com/terraform-docs/terraform-docs#installation"
    return 1
  fi
  # Check the latest available version of terraform-docs
  TERRAFORM_DOCS_VERSION=$(curl -s https://api.github.com/repos/terraform-docs/terraform-docs/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TERRAFORM_DOCS_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of terraform-docs"
    return 1
  fi
  # Check if terraform-docs is already installed and if the current version matches the version to be set
  if command -v terraform-docs &> /dev/null; then
    if [[ "$(terraform-docs --version | sed -r 's/v([0-9]\.[0-9]+\.[0-9]+)/\1/')" == "${TERRAFORM_DOCS_VERSION}" ]]; then
      echo "terraform-docs ${TERRAFORM_DOCS_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "terraform-docs is not installed or is not the correct version.  Installing terraform-docs v${TERRAFORM_DOCS_VERSION}"
  # Install terraform-docs using Go
  echo "Installing terraform-docs using Go"
  go get -u github.com/terraform-docs/terraform-docs/cmd/terraform-docs@latest
  # Check if the version installed is the correct version and if not report an error
  if [[ "$(terraform-docs --version | sed -r 's/v([0-9]\.[0-9]+\.[0-9]+)/\1/')" != "${TERRAFORM_DOCS_VERSION}" ]]; then
    echo "[ERROR] Error installing terraform-docs v${TERRAFORM_DOCS_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "terraform-docs v${TERRAFORM_DOCS_VERSION} installed"
}

# Install terraform-docs for Mac
terraform-docs-mac-install () {
  # Referring to https://github.com/terraform-docs/terraform-docs#installation
  # Check the latest available version of terraform-docs
  TERRAFORM_DOCS_VERSION=$(curl -s https://api.github.com/repos/terraform-docs/terraform-docs/releases/latest | grep '"tag_name":' | sed -E 's/.+"v([^"]+)".+/\1/')
  # Check if the version is set and if not report an error
  if [[ -z ${TERRAFORM_DOCS_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of terraform-docs"
    return 1
  fi
  # Check if terraform-docs is already installed and if the current version matches the version to be set
  if command -v terraform-docs &> /dev/null; then
    if [[ "$(terraform-docs --version | sed -r 's/v([0-9]\.[0-9]+\.[0-9]+)/\1/')" == "${TERRAFORM_DOCS_VERSION}" ]]; then
      echo "terraform-docs ${TERRAFORM_DOCS_VERSION} is already installed and is the latest version"
      return 0
    fi
  fi
  echo "terraform-docs is not installed or is not the correct version.  Installing terraform-docs v${TERRAFORM_DOCS_VERSION}"
  # Use Homebrew to install terraform-docs
  # Check if Homebrew is installed and if not report an error
  if ! command -v brew &> /dev/null; then
    echo "[ERROR] Homebrew is not installed.  Please install Homebrew and try again"
    return 1
  fi
  # Check if terraform-docs is already installed, if not install it, if it is then upgrade it
  if command -v terraform-docs &> /dev/null; then
    echo "Upgrading terraform-docs"
    brew upgrade terraform-docs
  else
    echo "Installing terraform-docs"
    brew install terraform-docs
  fi
  # Check if terraform-docs is installed and if not report an error
  if ! command -v terraform-docs &> /dev/null; then
    echo "[ERROR] Error installing terraform-docs"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  echo "terraform-docs ${TERRAFORM_DOCS_VERSION} installed"
}

# Install ansible using pip3 after confirming that the latest version is not already installed
ansible-install () {
  # Check the latest available version of Ansible by grepping the "version" field from the JSON output of the PyPi API
  PYPI_ANSIBLE_VERSION=$(curl -s https://pypi.org/pypi/ansible/json | grep -Eo '"version":"[0-9]+\.[0-9]+\.[0-9]+",' | sed -E 's/.+"([0-9]+\.[0-9]+\.[0-9]+)",/\1/')
  # PYPI_ANSIBLE_CORE=$(curl -s https://pypi.org/pypi/ansible/json | grep -Eo '\[\"ansible-core.*\"],' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
  PYPI_ANSIBLE_CORE=$(curl -s https://pypi.org/pypi/ansible/json | grep -Eo '\["ansible-core.*"],' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
  # Check if the version is set and if not report an error
  if [[ -z ${PYPI_ANSIBLE_VERSION} ]]; then
    echo "[ERROR] Unable to determine the latest version of Ansible"
    return 1
  fi
  # Test if pip3 is installed and if not report an error
  if ! command -v pip3 &> /dev/null; then
    echo "[ERROR] pip3 is not installed"
    echo "[INFO] Please install pip3 and try again"
    # Give an example of how to install pip3 using python3
    echo "[INFO] Example: python3 -m ensurepip --default-pip"    
    echo "[INFO] Confirm details with your specific distro, package manager of by referring to https://pip.pypa.io/en/stable/installation/"
    return 1
  fi
  # Using pip check if Ansible is already installed using pip and if the current version matches the version to be set
  if pip3 list --disable-pip-version-check | grep ansible &> /dev/null; then
    if [[ "$(pip3 list --disable-pip-version-check | grep -E 'ansible\s+' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')" == "${PYPI_ANSIBLE_VERSION}" ]]; then
      echo "Ansible ${PYPI_ANSIBLE_VERSION} with core version ${PYPI_ANSIBLE_CORE} is already installed and is the latest version"
      return 0
    fi
  fi
  # Check if ansible is already instaleld using another method, such as apt or dnf package managers and check the version.  If the ansible core versions macth then report and exit
  if command -v ansible &> /dev/null; then
    ANSIBLE_VERSION=$(ansible --version | grep -Eo 'core\s+[0-9]+\.[0-9]+\.[0-9]+' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
    if [[ "${ANSIBLE_VERSION}" == "${PYPI_ANSIBLE_CORE}" ]]; then
      echo "Ansible core version ${ANSIBLE_VERSION} is already installed using a method other than pip and is the latest version"
      return 0
    fi
  fi
  echo "Ansible is not installed or is not the correct version.  Installing Ansible v${PYPI_ANSIBLE_VERSION} from PyPi with core version ${PYPI_ANSIBLE_CORE}"
  # Install Ansible using pip3
  pip3 install ansible --disable-pip-version-check
  # Check if the version installed is the correct version and if not report an error
  if [[ "$(pip3 list --disable-pip-version-check | grep -E 'ansible\s+' | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')" != "${PYPI_ANSIBLE_VERSION}" ]]; then
    echo "[ERROR] Error installing Ansible v${PYPI_ANSIBLE_VERSION}"
    echo "[ERROR] Please check the version is valid and try again"
    return 1
  fi
  # Extract the version of Ansible installed and report it
  echo "Ansible core ${PYPI_ANSIBLE_CORE} installed from PyPi Ansible v${PYPI_ANSIBLE_VERSION} using pip3"
}

# Use ansible-vault to decrypt a list of file
avd () {
  # Check if variables are already set and if so unset -f
  if [[ -v VAULT_PASS ]]; then
    VAULT_PASS=""
  fi
  if [[ -v FILES ]]; then
    FILES=()
  fi
  # Check if ansible is installed
  if ! command -v ansible &> /dev/null
  then
      echo "[ERROR] Ansible could not be found"
      return 1
  fi
  # Use getopts to parse the arguments
  while getopts ":p:" opt; do
    case $opt in
      p) VAULT_PASS="$OPTARG"
         echo "Pass file is ${VAULT_PASS}" >&2
      ;;
      \?) echo "[ERROR] Invalid option -$OPTARG" >&2
          return 1
      ;;
    esac
  done

  # Process arguments excluding arguments passed as options
  shift $((OPTIND -1))
  echo "Processing ${*}"
  # If argument in $@ is not a switch or existing variable add it to an array of file names
  for arg in "${@}"; do
    if [[ ! $arg =~ ^-.* ]] || [[ ! -v $arg ]]; then
      # echo "adding $arg to FILES"
      FILES+=("$arg")
    fi
  done

  # If FILES is empty then report an error and return
  if [[ -z ${FILES[*]} ]]; then
    echo "[ERROR] No files to decrypt"
    return 1
  fi

  # Test if ansible.cfg exists and if vault_password_file is set, then test if the value for vault_password_file exists in the current directory.  If it does run ansible-vault decrypt without using the VAULT_PASS or prompting for a password
  if [[ -f "ansible.cfg" ]]; then
    if grep -q "vault_password_file" "ansible.cfg"; then
      if [[ -f "$(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')" ]]; then
        echo "Decrypting ${FILES[*]} with password file: $(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')"
        for file in "${FILES[@]}"; do
          # echo the command to be run
          # echo "ansible-vault decrypt ${file}"
          ansible-vault decrypt "${file}"
        done
        return 0
      fi
    fi
  fi

  # Check if the vault password file exists
  if [[ ! -f "${VAULT_PASS}" ]]; then
    echo "[WARN] Vault password file does not exist"
    # Remove VAULT_PASS from the environment
    VAULT_PASS=""
  fi

  if [[ ! -z "${VAULT_PASS}" ]]; then
    echo "Decrypting ${FILES[@]} with password file: ${VAULT_PASS}"
    for file in "${FILES[@]}"; do
      ansible-vault decrypt --vault-password-file "${VAULT_PASS}" "${file}"
    done
  else
    echo "Prompting for password to decrypt ${FILES[@]}"
    for file in "${FILES[@]}"; do
      ansible-vault decrypt "${file}"
    done
  fi

  # Remove all variables
  FILES=()
  VAULT_PASS=""
}

# Use ansible-vault to encrypt a list of file
ave () {
  # Check if variables are already set and if so unset -f
  if [[ -v VAULT_PASS ]]; then
    VAULT_PASS=""
  fi
  if [[ -v FILES ]]; then
    FILES=()
  fi
  # Check if ansible is installed
  if ! command -v ansible &> /dev/null
  then
      echo "[ERROR] Ansible could not be found"
      return 1
  fi
  # Use getopts to parse the arguments
  while getopts ":p:" opt; do
    case $opt in
      p) VAULT_PASS="$OPTARG"
         echo "Pass file is ${VAULT_PASS}" >&2
      ;;
      \?) echo "[ERROR] Invalid option -$OPTARG" >&2
          return 1
      ;;
    esac
  done

  # Process arguments excluding arguments passed as options
  shift $((OPTIND -1))
  echo "Processing ${@}"
  # If argument in $@ is not a switch or existing variable add it to an array of file names
  for arg in "${@}"; do
    if [[ ! $arg =~ ^-.* ]] || [[ ! -v $arg ]]; then
      echo "adding $arg to FILES"
      FILES+=("$arg")
    fi
  done

  # If FILES is empty then report an error and return
  if [[ -z ${FILES[*]} ]]; then
    echo "[ERROR] No files to encrypt"
    return 1
  fi

  # Test if ansible.cfg exists and if vault_password_file is set, then test if the value for vault_password_file exists in the current directory.  If it does run ansible-vault encrypt without using the VAULT_PASS or prompting for a password
  if [[ -f "ansible.cfg" ]]; then
    if grep -q "vault_password_file" "ansible.cfg"; then
      if [[ -f "$(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')" ]]; then
        echo "Encrypting ${FILES[*]} with password file: $(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')"
        for file in "${FILES[@]}"; do
          # echo the command to be run
          # echo "ansible-vault encrypt ${file}"
          ansible-vault encrypt "${file}"
        done
        return 0
      fi
    fi
  fi

  # Check if the vault password file exists
  if [[ ! -f "${VAULT_PASS}" ]]; then
    echo "[WARN] Vault password file does not exist"
    # Remove VAULT_PASS from the environment
    VAULT_PASS=""
  fi

  if [[ ! -z "${VAULT_PASS}" ]]; then
    echo "Encrypting ${FILES[@]} with password file: ${VAULT_PASS}"
    for file in "${FILES[@]}"; do
      ansible-vault encrypt --vault-password-file "${VAULT_PASS}" "${file}"
    done
  else
    echo "Prompting for password to encrypt ${FILES[@]}"
    for file in "${FILES[@]}"; do
      ansible-vault encrypt "${file}"
    done
  fi

  # Remove all variables
  FILES=()
  VAULT_PASS=""
}
