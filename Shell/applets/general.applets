#!/usr/bin/env bash

# Path: Shell/applets/general.applets
# Purpose: General purpose applets for shell commands
# Use: Add applets to this file and they will be sourced by ~/.applets

# This script adds helper functions to the shell
# It is sourced by .bashrc or .zshrc via ~/.applets
# Define additional functions here

# adding use of website cheat.sh for command lookup
cheat(){
    curl "https://cheat.sh/$1"
}

# Add to your shell rc file
dedupe_path() {
    if ! command -v awk &> /dev/null; then
        log_error "awk command not found, cannot deduplicate PATH"
        return 1
    fi
    if ! command -v tr &> /dev/null; then
        log_error "tr command not found, cannot deduplicate PATH"
        return 1
    fi
    if ! command -v sed &> /dev/null; then
        log_error "sed command not found, cannot deduplicate PATH"
        return 1
    fi
    # Remove duplicates from current session
    export PATH=$(echo "$PATH" | tr ':' '\n' | awk '!seen[$0]++' | tr '\n' ':' | sed 's/:$//')
}

# Cleanup removed branches in git
git-cleanup() {
    # Fetch updates
    git fetch -p

    # Remove local branches that have been deleted on the remote
    for branch in $(git branch -vv | grep ': gone]' | awk '{print $1}'); do
        log_info "Deleting branch $branch"
        git branch -D "$branch"
    done
}

# Show SSH Tunnel
show-ssh-tunnel(){
  # ps -aux | grep -iE 'ssh\s+(-[fNL]+\s+)*-?[fNL]+'
  pgrep -f 'ssh\s+(-[fNL]+\s+)*-?[fNL]+'
}

# Test sudo access
sudo-test (){
  # First check for traditional sudo access
  if [[ $(sudo -l -U "${USER}" 2>/dev/null) ]]; then
    return 0
  # Then check for run0 if available
  elif command -v run0 &>/dev/null && [[ $(run0 -l -U "${USER}" 2>/dev/null) ]]; then
    log_debug "User has run0 access instead of sudo"
    return 0
  else
    log_error "User does not have sudo access"
    return 1
  fi
}

# Get the elevation command (sudo or run0) that should be used
# This function will determine which privilege elevation mechanism is available
# and return the appropriate command name
get-elevation-command() {
  # Check for traditional sudo access first (most common)
  if command -v sudo &>/dev/null && [[ $(sudo -l -U "${USER}" 2>/dev/null) ]]; then
    echo "sudo"
    return 0
  # Then check for run0 if available
  elif command -v run0 &>/dev/null && [[ $(run0 -l -U "${USER}" 2>/dev/null) ]]; then
    log_debug "Using run0 instead of sudo for privilege elevation"
    echo "run0"
    return 0
  else
    log_error "No privilege elevation mechanism available (sudo or run0)"
    return 1
  fi
}

# Execute a command with privilege elevation (sudo or run0)
# This function handles the execution with the appropriate mechanism
# Usage: elevate-cmd "command to run with elevation"
elevate-cmd() {
  local elevation_cmd
  local cmd_to_run="$*"
  
  if [[ -z "$cmd_to_run" ]]; then
    log_error "No command specified for elevation"
    return 1
  fi
  
  elevation_cmd=$(get-elevation-command)
  if [[ $? -ne 0 || -z "$elevation_cmd" ]]; then
    log_error "Failed to determine elevation mechanism"
    return 1
  fi
  
  # If using run0, warn the user about potential multiple prompts
  if [[ "$elevation_cmd" == "run0" ]]; then
    log_warn "Using run0 for privilege elevation - you may be prompted multiple times"
    log_warn "run0 does not cache credentials like sudo does"
  fi
  
  log_debug "Executing with $elevation_cmd: $cmd_to_run"
  $elevation_cmd $cmd_to_run
  return $?
}

detect-package-manager() {
  # Detect the package manager for the current system
  if command -v apt &> /dev/null; then
    PACKAGE_MANAGER="apt"
  elif command -v dnf &> /dev/null; then
    PACKAGE_MANAGER="dnf"
  elif command -v yum &> /dev/null; then
    PACKAGE_MANAGER="yum"
  elif command -v zypper &> /dev/null; then
    PACKAGE_MANAGER="zypper"
  elif command -v pacman &> /dev/null; then
    PACKAGE_MANAGER="pacman"
  elif command -v brew &> /dev/null; then
    PACKAGE_MANAGER="brew"
  else
    log_error "No package manager found"
    return 1
  fi
  log_info "Using package manager: ${PACKAGE_MANAGER}"
  return 0
}

detect-distro () {
  # Detect the Linux distribution
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    if [[ -n ${NAME} ]]; then
      OS="${NAME}"
    fi
  fi
  if [[ -z ${OS} ]]; then
    log_error "Unable to detect OS"
    return 1
  fi
  log_info "Detected OS: ${OS}"
  return 0
}

# Single command to update all tools including in this script
update-tools () {
  set_log_format "%m"
  log_info "== Updating Tools =="
  log_info "== Updating AWS CLI =="
  aws-update
  log_info "== Updating Kubectl =="
  set_log_format "%d [%l] [%s] %m"
  log_info " Updating Kubectl to latest version - using set-kubectl -v <version> to set a specific version"
  set_log_format "%m"
  set-kubectl -s
  log_info "== Installing Helm =="
  helm-install
  log_info "== Updating Terraform =="
  terraform-install
  log_info "== Updating Ansible =="
  ansible-install
  log_info "== Updating Microsoft Edit =="
  install-edit
  set_log_format "%d [%l] [%s] %m"
  return 0
}

# Get the version of GO if installed and save it to an envrioment variable
get-go-version () {
  if [[ -x "$(command -v go)" ]]; then
    GO_VERSION=$(go version | awk '{print $3}'| tr -d 'go')
    export GO_VERSION
  else
    log_error "GO is not installed"
    return 1
  fi
}

get-python-versions () {
  echo "[INFO] Python versions found:"
  for version in /usr/bin/python3*; do
    # Ignore -config directories
    if [[ $version == *-config ]]; then
      continue
    fi
    # Print the base version of python3 such as 3.8, 3.9 etc. and then the full version
    echo "$(basename $version): $($version --version 2>&1)"
  done
}

# Get and return public IPv4 and IPv6 addresses
# Use dig if dig is available, otherwise use curl
get-public-ip () {
  if [[ -x "$(command -v dig)" ]]; then
    echo "IPv4: $(dig -4 TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')"
    echo "IPv6: $(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')"
  else
    echo "IPv4: $(curl -s https://ipv4.icanhazip.com)"
    echo "IPv6: $(curl -s https://ipv6.icanhazip.com)"
  fi
}

open-workspace () {
  if ! command -v code &> /dev/null && ! command -v code-insiders &> /dev/null; then
    log_error "Visual Studio Code is not installed"
    return 1
  fi
  # Accept a directory path as an argument or set ${HOME}/Developement/workspaces as the default
  local workspace_path="${1:-${HOME}/Development/workspaces}"
  local workspaces_full_path=()
  # Check if workspace_path is a symlink and if it is get the full path
  if [[ -L "${workspace_path}" ]]; then
    workspace_path=$(readlink -f "${workspace_path}")
  fi
  # Check if the directory exists and if it does ensure that we have the full valid path
  if [[ -d "${workspace_path}" ]]; then
    if command -v mapfile &> /dev/null; then
      mapfile -t workspaces_full_path < <(find "${workspace_path}" -type f -name "*.code-workspace")
    else
      # shellcheck disable=SC2207
      workspaces_full_path=($(find "${workspace_path}" -type f -name "*.code-workspace"))
    fi
  fi
  # Check if we have any workspaces
  if [[ ${#workspaces_full_path[@]} -eq 0 ]]; then
    log_error "No workspaces found in ${workspace_path}"
    return 1
  fi
  local workspaces=()
  for workspace in "${workspaces_full_path[@]}"; do
    workspaces+=("$(basename "${workspace}" .code-workspace)")
  done
  echo "Available workspaces:"
  PS3="Please select the number of a workspace to open: "
  select workspace in "${workspaces[@]}"; do
    if [[ -n "${workspace}" ]]; then
        for wsp in "${workspaces_full_path[@]}"; do
          if [[ "${workspace}" == "$(basename "${wsp}" .code-workspace)" ]]; then
            if command -v code-insiders &> /dev/null; then
              code-insiders "${wsp}"
            else
              code "${wsp}"
            fi
            break
          fi
        done
      break
    else
      log_error "Invalid selection, try again"
    fi
  done
 }

 # to reregister LUKS key with tpm2 using systemd-crpytenroll
 # Requires the tpm2-tools and dracut tools to be installed
 register-tpm () {
    # Use lsblk with JSON output for easier parsing
    local IFS=$'\n'
    local luks_devices=()
    local partition_device=""
    local enrolled_count=0

    # Check if the required tools are installed
    if ! command -v lsblk &> /dev/null; then
        log_error "Required tools are not installed. Please install lsblk" >&2
        return 1
    fi
    if ! command -v tpm2 &> /dev/null || ! command -v dracut &> /dev/null; then
        log_error "Required tools are not installed. Please install tpm2-tools and dracut" >&2
        return 1
    fi
    if ! command -v cryptsetup &> /dev/null || ! command -v systemd-cryptenroll &> /dev/null; then
        log_error "Required tools are not installed. Please install cryptsetup and systemd-cryptenroll" >&2
        return 1
    fi

    # Check if user has sudo access
    if ! sudo-test; then
        return 1
    fi

    # Process lsblk output to find LUKS partitions
    while read -r line; do
        # Skip header line
        if [[ $line =~ ^NAME ]]; then
            continue
        fi

        # Check if this is a partition line that's followed by a LUKS device
        if [[ $line =~ p[0-9]+[[:space:]] && ! $line =~ crypt ]]; then
            # Extract the partition name, handling the tree structure
            partition_device=$(echo "$line" | awk '{print $1}' | tr -d '└─├─')
            
            # Look at the next line to see if it's a LUKS device
            read -r next_line
            
            if [[ $next_line =~ crypt ]]; then
                device_path="/dev/$partition_device"
                
                if sudo cryptsetup isLuks "$device_path"; then
                    echo "[INFO] Found LUKS encrypted partition: $device_path"
                    luks_devices+=("$device_path")
                fi
            fi
        fi
    done < <(lsblk)

    # Process all found LUKS devices
    for device_path in "${luks_devices[@]}"; do
        echo "[INFO] Enrolling TPM2 for $device_path..."
        if sudo systemd-cryptenroll \
            --wipe-slot=tpm2 \
            --tpm2-device=auto \
            --tpm2-pcrs="0+2+4+5+7" \
            "$device_path"; then
            log_info "Successfully enrolled TPM2 for $device_path"
            ((enrolled_count++))
        else
            log_error "Failed to enroll TPM2 for $device_path" >&2
        fi
    done

    log_info "TPM2 enrollment completed. Successfully enrolled $enrolled_count devices."
    luks_devices=()
    return 0
 }

 get-my-functions () {
  echo
  echo "[INFO] Loaded functions:"
  if [[ -n ${BASH_VERSION} ]]; then
    for func in $(declare -F | awk '{print $3}'); do
      if grep -q "^${func}[[:space:]]*()[[:space:]]*{" "${HOME}/Development/Personal/GitHub/linuxDotFiles/Shell/applets/"*.applets 2>/dev/null; then
        echo "${func}"
      fi
    done | sort | column
  elif [[ -n ${ZSH_VERSION} ]]; then
    grep -Eo '^[a-zA-Z_-][a-zA-Z0-9_-]*\s?\(\)' "${HOME}/applets/"/**/*.applets | sed 's/()//' | awk -F: '{print $NF}' | sort | column
  fi
  echo
  echo "[INFO] Loaded aliases:"
  if [[ -n ${BASH_VERSION} ]]; then
    alias | sed 's/alias //g' | awk -F= '{print $1}' | sort | column
  elif [[ -n ${ZSH_VERSION} ]]; then
    alias -L | sed 's/alias //g' | awk -F= '{print $1}' | sort | column
  fi
 }

list-ssh-hosts() {
  local config_dir="${HOME}/.ssh/config.d"
  local main_config="${HOME}/.ssh/config"
  
  # Process main config file
  echo "=== Main Config ==="
  grep -E "^Host\s" "${main_config}" | sed 's/Host //'
  echo

  # Process each file in config.d
  if [[ -d "$config_dir" ]]; then
      for config_file in "${config_dir}"/*; do
          if [ -f "$config_file" ]; then
              echo "=== $(basename "$config_file") ==="
              grep -E "^Host\s" "$config_file" | sed 's/Host //'
              echo
          fi
      done
  fi
}

install-bitwarden() {
  log_info "Installing or updating Bitwarden password manager..."
  
  # Detect package manager if not already set
  if [[ -z "${PACKAGE_MANAGER}" ]]; then
    detect-package-manager || return 1
  fi
  
  # Check for privilege elevation access
  if [[ "${PACKAGE_MANAGER}" == "apt" || "${PACKAGE_MANAGER}" == "dnf" || "${PACKAGE_MANAGER}" == "yum" || "${PACKAGE_MANAGER}" == "zypper" || "${PACKAGE_MANAGER}" == "pacman" ]]; then
    log_info "Checking privilege elevation access for package installation..."
    if ! sudo-test; then
      log_error "This installation requires administrator privileges. Please try again with appropriate permissions."
      return 1
    fi
    
    # Get the elevation command to use
    local elevation_cmd
    elevation_cmd=$(get-elevation-command)
    if [[ -z "${elevation_cmd}" ]]; then
      log_error "Failed to determine elevation mechanism"
      return 1
    fi
    
    # If using run0, warn about multiple prompts
    if [[ "${elevation_cmd}" == "run0" ]]; then
      log_warn "Using run0 for package installation - you may be prompted multiple times during this operation"
      log_warn "run0 does not cache credentials like sudo does"
    fi
  fi
  
  # Create temp directory for downloads
  local temp_dir
  temp_dir=$(mktemp -d)
  log_debug "Created temporary directory: ${temp_dir}"
  
  # Install based on detected package manager
  case "${PACKAGE_MANAGER}" in
    apt)
      log_info "Using APT package manager - installing DEB package"
      local deb_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=deb"
      local deb_file="${temp_dir}/bitwarden.deb"
      
      # Download the DEB package
      log_info "Downloading Bitwarden DEB package..."
      if ! curl -L -o "${deb_file}" "${deb_url}"; then
        log_error "Failed to download Bitwarden DEB package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the DEB package
      log_info "Installing Bitwarden..."
      if ! ${elevation_cmd} dpkg -i "${deb_file}"; then
        log_error "Failed to install Bitwarden DEB package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Fix any dependency issues
      log_info "Resolving dependencies..."
      ${elevation_cmd} apt-get install -f -y
      ;;
      
    dnf|yum)
      log_info "Using ${PACKAGE_MANAGER} package manager - installing RPM package"
      local rpm_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=rpm"
      local rpm_file="${temp_dir}/bitwarden.rpm"
      
      # Download the RPM package
      log_info "Downloading Bitwarden RPM package..."
      if ! curl -L -o "${rpm_file}" "${rpm_url}"; then
        log_error "Failed to download Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the RPM package
      log_info "Installing Bitwarden..."
      if ! ${elevation_cmd} ${PACKAGE_MANAGER} install -y "${rpm_file}"; then
        log_error "Failed to install Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
      
    zypper)
      log_info "Using Zypper package manager - installing RPM package"
      local rpm_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=rpm"
      local rpm_file="${temp_dir}/bitwarden.rpm"
      
      # Download the RPM package
      log_info "Downloading Bitwarden RPM package..."
      if ! curl -L -o "${rpm_file}" "${rpm_url}"; then
        log_error "Failed to download Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the RPM package
      log_info "Installing Bitwarden..."
      if ! ${elevation_cmd} zypper install -y "${rpm_file}"; then
        log_error "Failed to install Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
      
    pacman)
      log_info "Using Pacman package manager"
      
      # Check if yay is available for AUR access
      if command -v yay &> /dev/null; then
        log_info "Installing Bitwarden using yay (AUR)..."
        if ! yay -S --noconfirm bitwarden-bin; then
          log_error "Failed to install Bitwarden using yay"
          rm -rf "${temp_dir}"
          return 1
        fi
      else
        # Try using the AppImage as fallback
        log_info "Installing Bitwarden AppImage..."
        local appimage_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=appimage"
        local appimage_file="${HOME}/Applications/Bitwarden.AppImage"
        
        # Create Applications directory if it doesn't exist
        mkdir -p "${HOME}/Applications"
        
        # Download the AppImage
        if ! curl -L -o "${appimage_file}" "${appimage_url}"; then
          log_error "Failed to download Bitwarden AppImage"
          rm -rf "${temp_dir}"
          return 1
        fi
        
        # Make it executable
        chmod +x "${appimage_file}"
        log_info "Bitwarden AppImage installed to ${appimage_file}"
      fi
      ;;
      
    *)
      # Try flatpak as a fallback
      if command -v flatpak &> /dev/null; then
        log_warn "Native package not available for ${PACKAGE_MANAGER}. Using Flatpak instead."
        
        # Add Flathub repository if not already added
        if ! flatpak remotes | grep -q "flathub"; then
          log_info "Adding Flathub repository..."
          flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        fi
        
        # Install Bitwarden flatpak
        log_info "Installing Bitwarden via Flatpak..."
        if ! flatpak install -y flathub com.bitwarden.desktop; then
          log_error "Failed to install Bitwarden via Flatpak"
          rm -rf "${temp_dir}"
          return 1
        fi
      else
        log_error "No supported package manager found. Please install Bitwarden manually."
        log_info "Visit https://bitwarden.com/download/ for installation options."
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
  esac
  
  # Clean up
  log_debug "Cleaning up temporary files"
  rm -rf "${temp_dir}"
  
  log_info "Bitwarden installation completed successfully!"
  return 0
}

install-opendeck() {
  log_info "Installing or updating OpenDeck..."
  
  # Detect package manager if not already set
  if [[ -z "${PACKAGE_MANAGER}" ]]; then
    detect-package-manager || return 1
  fi
  
  # Check for privilege elevation access
  if [[ "${PACKAGE_MANAGER}" == "apt" || "${PACKAGE_MANAGER}" == "dnf" || "${PACKAGE_MANAGER}" == "yum" || "${PACKAGE_MANAGER}" == "zypper" || "${PACKAGE_MANAGER}" == "pacman" ]]; then
    log_info "Checking privilege elevation access for package installation..."
    if ! sudo-test; then
      log_error "This installation requires administrator privileges. Please try again with appropriate permissions."
      return 1
    fi
    
    # Get the elevation command to use
    local elevation_cmd
    elevation_cmd=$(get-elevation-command)
    if [[ -z "${elevation_cmd}" ]]; then
      log_error "Failed to determine elevation mechanism"
      return 1
    fi
    
    # If using run0, warn about multiple prompts
    if [[ "${elevation_cmd}" == "run0" ]]; then
      log_warn "Using run0 for package installation - you may be prompted multiple times during this operation"
      log_warn "run0 does not cache credentials like sudo does"
    fi
  fi
  
  # Get latest release information from GitHub API
  log_info "Fetching latest OpenDeck release information..."
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/nekename/OpenDeck/releases/latest")
  
  if [[ -z "$api_response" ]]; then
    log_error "Failed to fetch release information from GitHub API"
    return 1
  fi
  
  # Extract version and download URLs
  local version
  local download_url=""
  local asset_name=""
  
  # Parse version
  version=$(echo "$api_response" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/')
  
  if [[ -z "$version" ]]; then
    log_error "Could not determine latest version from GitHub API"
    return 1
  fi
  
  log_info "Latest OpenDeck version: ${version}"
  
  # Check if OpenDeck is already installed and get current version
  if command -v opendeck &> /dev/null; then
    # Try to get current version - this may vary depending on how OpenDeck reports version
    local current_version
    current_version=$(opendeck --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    
    if [[ -n "$current_version" && "$current_version" == "${version#v}" ]]; then
      log_info "OpenDeck ${current_version} is already installed and up to date"
      return 0
    fi
  fi
  
  # Create temp directory for downloads
  local temp_dir
  temp_dir=$(mktemp -d)
  log_debug "Created temporary directory: ${temp_dir}"
  
  # Determine appropriate package based on package manager
  case "${PACKAGE_MANAGER}" in
    apt)
      log_info "Looking for DEB package..."
      # Parse assets for .deb file
      download_url=$(echo "$api_response" | grep '"browser_download_url":.*\.deb"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
      asset_name=$(basename "$download_url")
      
      if [[ -z "$download_url" ]]; then
        log_error "No DEB package found in latest release"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      local package_file="${temp_dir}/${asset_name}"
      
      # Download the package
      log_info "Downloading OpenDeck DEB package: ${asset_name}"
      if ! curl -L -o "${package_file}" "${download_url}"; then
        log_error "Failed to download OpenDeck DEB package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the package
      log_info "Installing OpenDeck..."
      if ! ${elevation_cmd} dpkg -i "${package_file}"; then
        log_warn "dpkg installation may have dependency issues, trying to resolve..."
        ${elevation_cmd} apt-get install -f -y
      fi
      ;;
      
    dnf|yum)
      log_info "Looking for RPM package..."
      # Parse assets for .rpm file
      download_url=$(echo "$api_response" | grep '"browser_download_url":.*\.rpm"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
      asset_name=$(basename "$download_url")
      
      if [[ -z "$download_url" ]]; then
        log_error "No RPM package found in latest release"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      local package_file="${temp_dir}/${asset_name}"
      
      # Download the package
      log_info "Downloading OpenDeck RPM package: ${asset_name}"
      if ! curl -L -o "${package_file}" "${download_url}"; then
        log_error "Failed to download OpenDeck RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the package
      log_info "Installing OpenDeck..."
      if ! ${elevation_cmd} ${PACKAGE_MANAGER} install -y "${package_file}"; then
        log_error "Failed to install OpenDeck RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
      
    zypper)
      log_info "Looking for RPM package for openSUSE..."
      # Parse assets for .rpm file
      download_url=$(echo "$api_response" | grep '"browser_download_url":.*\.rpm"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
      asset_name=$(basename "$download_url")
      
      if [[ -z "$download_url" ]]; then
        log_error "No RPM package found in latest release"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      local package_file="${temp_dir}/${asset_name}"
      
      # Download the package
      log_info "Downloading OpenDeck RPM package: ${asset_name}"
      if ! curl -L -o "${package_file}" "${download_url}"; then
        log_error "Failed to download OpenDeck RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the package
      log_info "Installing OpenDeck..."
      if ! ${elevation_cmd} zypper install -y "${package_file}"; then
        log_error "Failed to install OpenDeck RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
      
    pacman)
      log_info "Looking for generic package for Arch Linux..."
      # For Arch, we might need to look for a tar.xz or similar package
      # Or potentially build from AUR - this depends on what OpenDeck provides
      download_url=$(echo "$api_response" | grep '"browser_download_url":.*\.tar\.xz"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
      
      if [[ -z "$download_url" ]]; then
        # Fallback to looking for any Linux binary
        download_url=$(echo "$api_response" | grep '"browser_download_url":.*linux.*' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/' | head -1)
      fi
      
      if [[ -z "$download_url" ]]; then
        log_warn "No native Arch package found. You may need to install from AUR or build manually."
        log_info "Visit https://github.com/nekename/OpenDeck/releases/latest for manual installation"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      asset_name=$(basename "$download_url")
      local package_file="${temp_dir}/${asset_name}"
      
      # Download and extract if it's a tar.xz
      log_info "Downloading OpenDeck package: ${asset_name}"
      if ! curl -L -o "${package_file}" "${download_url}"; then
        log_error "Failed to download OpenDeck package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # This would need to be customized based on actual package format
      log_warn "Manual installation may be required for Arch Linux"
      log_info "Downloaded to: ${package_file}"
      ;;
      
    *)
      # Try flatpak as a fallback or look for AppImage
      log_info "Looking for AppImage or generic Linux binary..."
      
      # Look for AppImage first
      download_url=$(echo "$api_response" | grep '"browser_download_url":.*\.AppImage"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
      
      if [[ -n "$download_url" ]]; then
        asset_name=$(basename "$download_url")
        local appimage_file="${HOME}/Applications/${asset_name}"
        
        # Create Applications directory if it doesn't exist
        mkdir -p "${HOME}/Applications"
        
        # Download the AppImage
        log_info "Downloading OpenDeck AppImage: ${asset_name}"
        if ! curl -L -o "${appimage_file}" "${download_url}"; then
          log_error "Failed to download OpenDeck AppImage"
          rm -rf "${temp_dir}"
          return 1
        fi
        
        # Make it executable
        chmod +x "${appimage_file}"
        log_info "OpenDeck AppImage installed to ${appimage_file}"
        
        # Optionally create a desktop entry or symlink
        if [[ ! -L "${HOME}/.local/bin/opendeck" ]]; then
          ln -s "${appimage_file}" "${HOME}/.local/bin/opendeck"
          log_info "Created symlink in ${HOME}/.local/bin/opendeck"
        fi
      else
        log_error "No supported package format found for your system"
        log_info "Supported package managers: apt (DEB), dnf/yum (RPM), zypper (RPM)"
        log_info "Visit https://github.com/nekename/OpenDeck/releases/latest for manual installation"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
  esac
  
  # Clean up
  log_debug "Cleaning up temporary files"
  rm -rf "${temp_dir}"
  
  # Verify installation
  if command -v opendeck &> /dev/null; then
    local installed_version
    installed_version=$(opendeck --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    log_info "OpenDeck installation completed successfully!"
    if [[ -n "$installed_version" ]]; then
      log_info "Installed version: ${installed_version}"
    fi
  else
    log_warn "Installation completed but 'opendeck' command not found in PATH"
    log_info "You may need to restart your shell or check the installation"
  fi
  
  return 0
}

# Function to list available OpenDeck releases
list-opendeck-releases() {
  log_info "Fetching OpenDeck release information..."
  
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/nekename/OpenDeck/releases")
  
  if [[ -z "$api_response" ]]; then
    log_error "Failed to fetch release information from GitHub API"
    return 1
  fi
  
  echo "Available OpenDeck releases:"
  echo "$api_response" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/' | head -10
}

# Function to install a specific version of OpenDeck
install-opendeck-version() {
  local target_version="$1"
  
  if [[ -z "$target_version" ]]; then
    log_error "Please specify a version to install"
    log_info "Usage: install-opendeck-version <version>"
    log_info "Use 'list-opendeck-releases' to see available versions"
    return 1
  fi
  
  log_info "Installing OpenDeck version: ${target_version}"
  
  # Modify the API URL to get specific version
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/nekename/OpenDeck/releases/tags/${target_version}")
  
  if [[ -z "$api_response" ]] || echo "$api_response" | grep -q '"message": "Not Found"'; then
    log_error "Version ${target_version} not found"
    log_info "Use 'list-opendeck-releases' to see available versions"
    return 1
  fi
  
  # The rest follows the same logic as install-opendeck but with the specific version
  # For brevity, this would essentially be the same function with the API response
  # already set to the specific version
  log_info "Feature not fully implemented - use install-opendeck for latest version"
  return 1
}

install-edit() {
  log_info "Installing or updating Microsoft Edit CLI editor..."
  
  # Check if required tools are available
  if ! command -v curl &> /dev/null; then
    log_error "curl is required but not installed. Please install curl first."
    return 1
  fi
  
  if ! command -v tar &> /dev/null; then
    log_error "tar is required but not installed. Please install tar first."
    return 1
  fi
  
  # Check for zstd support (needed for .tar.zst files)
  if ! command -v zstd &> /dev/null; then
    log_warn "zstd is not installed. Attempting to install it..."
    
    # Detect package manager if not already set
    if [[ -z "${PACKAGE_MANAGER}" ]]; then
      detect-package-manager || {
        log_error "Could not detect package manager to install zstd. Please install zstd manually."
        return 1
      }
    fi
    
    # Check for privilege elevation access
    if ! sudo-test; then
      log_error "This installation requires administrator privileges to install zstd. Please install zstd manually or run with appropriate permissions."
      return 1
    fi
    
    # Get the elevation command to use
    local elevation_cmd
    elevation_cmd=$(get-elevation-command)
    if [[ -z "${elevation_cmd}" ]]; then
      log_error "Failed to determine elevation mechanism"
      return 1
    fi
    
    # Install zstd based on package manager
    case "${PACKAGE_MANAGER}" in
      apt)
        ${elevation_cmd} apt-get update && ${elevation_cmd} apt-get install -y zstd
        ;;
      dnf|yum)
        ${elevation_cmd} ${PACKAGE_MANAGER} install -y zstd
        ;;
      zypper)
        ${elevation_cmd} zypper install -y zstd
        ;;
      pacman)
        ${elevation_cmd} pacman -S --noconfirm zstd
        ;;
      *)
        log_error "Unable to install zstd for package manager: ${PACKAGE_MANAGER}"
        log_info "Please install zstd manually and try again"
        return 1
        ;;
    esac
    
    # Verify zstd installation
    if ! command -v zstd &> /dev/null; then
      log_error "Failed to install zstd. Please install it manually."
      return 1
    fi
  fi
  
  # Get latest release information from GitHub API
  log_info "Fetching latest Microsoft Edit release information..."
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/microsoft/edit/releases/latest")
  
  if [[ -z "$api_response" ]]; then
    log_error "Failed to fetch release information from GitHub API"
    return 1
  fi
  
  # Extract version
  local version
  version=$(echo "$api_response" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/')
  
  if [[ -z "$version" ]]; then
    log_error "Could not determine latest version from GitHub API"
    return 1
  fi
  
  log_info "Latest Microsoft Edit version: ${version}"
  
  # Check if Edit is already installed and get current version
  if command -v edit &> /dev/null; then
    # Try to get current version
    local current_version
    current_version=$(edit --version 2>/dev/null | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    
    if [[ -n "$current_version" ]]; then
      # Normalize version strings (remove 'v' prefix if present)
      local normalized_current="${current_version#v}"
      local normalized_latest="${version#v}"
      
      if [[ "$normalized_current" == "$normalized_latest" ]]; then
        log_info "Microsoft Edit ${normalized_current} is already installed and up to date"
        return 0
      else
        log_info "Current version: ${normalized_current}, updating to: ${normalized_latest}"
      fi
    fi
  fi
  
  # Detect architecture
  local arch
  case "$(uname -m)" in
    x86_64)
      arch="x86_64-linux-gnu"
      ;;
    aarch64|arm64)
      arch="aarch64-linux-gnu"
      ;;
    *)
      log_error "Unsupported architecture: $(uname -m)"
      log_info "Microsoft Edit currently supports x86_64 and aarch64 architectures"
      return 1
      ;;
  esac
  
  # Construct download URL and asset name (normalize version by removing 'v' prefix)
  local normalized_version="${version#v}"
  local asset_name="edit-${normalized_version}-${arch}.tar.zst"
  local download_url
  download_url=$(echo "$api_response" | grep '"browser_download_url":.*'"${asset_name}"'"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
  
  if [[ -z "$download_url" ]]; then
    log_error "Could not find download URL for ${asset_name}"
    log_info "Available assets:"
    echo "$api_response" | grep '"name":.*\.tar\.zst"' | sed -E 's/.*"name": *"([^"]+)".*/\1/'
    return 1
  fi
  
  # Create temp directory for downloads
  local temp_dir
  temp_dir=$(mktemp -d)
  log_debug "Created temporary directory: ${temp_dir}"
  
  # Download the package
  local package_file="${temp_dir}/${asset_name}"
  log_info "Downloading Microsoft Edit: ${asset_name}"
  
  if ! curl -L -o "${package_file}" "${download_url}"; then
    log_error "Failed to download Microsoft Edit package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Create installation directory
  local install_dir="${HOME}/.local/bin"
  mkdir -p "${install_dir}"
  
  # Extract and install
  log_info "Extracting Microsoft Edit..."
  
  # Extract the tar.zst file
  if ! tar -xf "${package_file}" -C "${temp_dir}"; then
    log_error "Failed to extract Microsoft Edit package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Find the extracted edit binary
  local edit_binary
  edit_binary=$(find "${temp_dir}" -name "edit" -type f -executable | head -1)
  
  if [[ -z "$edit_binary" ]]; then
    log_error "Could not find edit binary in extracted package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Copy the binary to the installation directory
  if ! cp "${edit_binary}" "${install_dir}/edit"; then
    log_error "Failed to copy edit binary to ${install_dir}"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Make sure it's executable
  chmod +x "${install_dir}/edit"
  
  # Clean up
  log_debug "Cleaning up temporary files"
  rm -rf "${temp_dir}"
  
  # Verify installation
  if command -v edit &> /dev/null; then
    local installed_version
    installed_version=$(edit --version 2>/dev/null | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    log_info "Microsoft Edit installation completed successfully!"
    if [[ -n "$installed_version" ]]; then
      log_info "Installed version: ${installed_version}"
    fi
    
    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
      log_warn "${HOME}/.local/bin is not in your PATH. Add it to your shell profile:"
      log_warn "echo 'export PATH=\"\${HOME}/.local/bin:\$PATH\"' >> ~/.bashrc"
      log_warn "or"
      log_warn "echo 'export PATH=\"\${HOME}/.local/bin:\$PATH\"' >> ~/.zshrc"
    fi
  else
    log_warn "Installation completed but 'edit' command not found in PATH"
    log_info "You may need to restart your shell or add ~/.local/bin to your PATH"
  fi
  
  return 0
}

# Function to list available Microsoft Edit releases
list-edit-releases() {
  log_info "Fetching Microsoft Edit release information..."
  
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/microsoft/edit/releases")
  
  if [[ -z "$api_response" ]]; then
    log_error "Failed to fetch release information from GitHub API"
    return 1
  fi
  
  echo "Available Microsoft Edit releases:"
  echo "$api_response" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/' | head -10
}

# Function to install a specific version of Microsoft Edit
install-edit-version() {
  local target_version="$1"
  
  if [[ -z "$target_version" ]]; then
    log_error "Please specify a version to install"
    log_info "Usage: install-edit-version <version>"
    log_info "Use 'list-edit-releases' to see available versions"
    return 1
  fi
  
  log_info "Installing Microsoft Edit version: ${target_version}"
  
  # Check if required tools are available
  if ! command -v curl &> /dev/null; then
    log_error "curl is required but not installed. Please install curl first."
    return 1
  fi
  
  if ! command -v tar &> /dev/null; then
    log_error "tar is required but not installed. Please install tar first."
    return 1
  fi
  
  if ! command -v zstd &> /dev/null; then
    log_error "zstd is required but not installed. Please install zstd first or use install-edit which will attempt to install it."
    return 1
  fi
  
  # Modify the API URL to get specific version
  local api_response
  api_response=$(curl -s "https://api.github.com/repos/microsoft/edit/releases/tags/${target_version}")
  
  if [[ -z "$api_response" ]] || echo "$api_response" | grep -q '"message": "Not Found"'; then
    log_error "Version ${target_version} not found"
    log_info "Use 'list-edit-releases' to see available versions"
    return 1
  fi
  
  # Detect architecture
  local arch
  case "$(uname -m)" in
    x86_64)
      arch="x86_64-linux-gnu"
      ;;
    aarch64|arm64)
      arch="aarch64-linux-gnu"
      ;;
    *)
      log_error "Unsupported architecture: $(uname -m)"
      log_info "Microsoft Edit currently supports x86_64 and aarch64 architectures"
      return 1
      ;;
  esac
  
  # Construct download URL and asset name (normalize version by removing 'v' prefix)
  local normalized_version="${target_version#v}"
  local asset_name="edit-${normalized_version}-${arch}.tar.zst"
  local download_url
  download_url=$(echo "$api_response" | grep '"browser_download_url":.*'"${asset_name}"'"' | sed -E 's/.*"browser_download_url": *"([^"]+)".*/\1/')
  
  if [[ -z "$download_url" ]]; then
    log_error "Could not find download URL for ${asset_name}"
    log_info "Available assets for ${target_version}:"
    echo "$api_response" | grep '"name":.*\.tar\.zst"' | sed -E 's/.*"name": *"([^"]+)".*/\1/'
    return 1
  fi
  
  # Create temp directory for downloads
  local temp_dir
  temp_dir=$(mktemp -d)
  log_debug "Created temporary directory: ${temp_dir}"
  
  # Download the package
  local package_file="${temp_dir}/${asset_name}"
  log_info "Downloading Microsoft Edit ${target_version}: ${asset_name}"
  
  if ! curl -L -o "${package_file}" "${download_url}"; then
    log_error "Failed to download Microsoft Edit package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Create installation directory
  local install_dir="${HOME}/.local/bin"
  mkdir -p "${install_dir}"
  
  # Extract and install
  log_info "Extracting Microsoft Edit..."
  
  # Extract the tar.zst file
  if ! tar -xf "${package_file}" -C "${temp_dir}"; then
    log_error "Failed to extract Microsoft Edit package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Find the extracted edit binary
  local edit_binary
  edit_binary=$(find "${temp_dir}" -name "edit" -type f -executable | head -1)
  
  if [[ -z "$edit_binary" ]]; then
    log_error "Could not find edit binary in extracted package"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Copy the binary to the installation directory
  if ! cp "${edit_binary}" "${install_dir}/edit"; then
    log_error "Failed to copy edit binary to ${install_dir}"
    rm -rf "${temp_dir}"
    return 1
  fi
  
  # Make sure it's executable
  chmod +x "${install_dir}/edit"
  
  # Clean up
  log_debug "Cleaning up temporary files"
  rm -rf "${temp_dir}"
  
  # Verify installation
  if command -v edit &> /dev/null; then
    local installed_version
    installed_version=$(edit --version 2>/dev/null | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    log_info "Microsoft Edit ${target_version} installation completed successfully!"
    if [[ -n "$installed_version" ]]; then
      log_info "Installed version: ${installed_version}"
    fi
    
    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
      log_warn "${HOME}/.local/bin is not in your PATH. Add it to your shell profile:"
      log_warn "echo 'export PATH=\"\${HOME}/.local/bin:\$PATH\"' >> ~/.bashrc"
      log_warn "or"
      log_warn "echo 'export PATH=\"\${HOME}/.local/bin:\$PATH\"' >> ~/.zshrc"
    fi
  else
    log_warn "Installation completed but 'edit' command not found in PATH"
    log_info "You may need to restart your shell or add ~/.local/bin to your PATH"
  fi
  
  return 0
}

# Function to copy SSH keys from Bitwarden SSH Agent to remote servers
ssh-copy-bw() {
    local usage="Usage: ssh-copy-bw [--all] <user@host|user host> [key_pattern]
    
Examples:
  ssh-copy-bw gwatts@192.168.124.191 \"GW - Personal\"
  ssh-copy-bw gwatts 192.168.124.191 \"2025-01-30\"
  ssh-copy-bw --all gwatts@192.168.124.191
  ssh-copy-bw root@server.example.com \"ED25519\""

    local copy_all=false
    local user_host=""
    local key_pattern=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all)
                copy_all=true
                shift
                ;;
            -h|--help)
                echo "$usage"
                return 0
                ;;
            *)
                if [[ -z "$user_host" ]]; then
                    user_host="$1"
                elif [[ "$user_host" != *"@"* ]] && [[ -z "$key_pattern" ]]; then
                    # Handle "user host" format
                    user_host="$user_host@$1"
                elif [[ -z "$key_pattern" ]]; then
                    key_pattern="$1"
                else
                    log_error "Too many arguments"
                    echo "$usage"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$user_host" ]]; then
        log_error "user@host is required"
        echo "$usage"
        return 1
    fi
    
    if [[ "$copy_all" == false ]] && [[ -z "$key_pattern" ]]; then
        log_error "key pattern is required unless --all is specified"
        echo "$usage"
        return 1
    fi
    
    # Get available keys
    local available_keys
    if ! available_keys=$(ssh-add -L 2>/dev/null); then
      log_error "No SSH keys found in agent or ssh-add failed"
      return 1
    fi
    
    if [[ -z "$available_keys" ]]; then
      log_error "No SSH keys available in agent"
      return 1
    fi
    
    local keys_to_copy=""
    
    if [[ "$copy_all" == true ]]; then
        keys_to_copy="$available_keys"
        log_info "Found $(echo "$available_keys" | wc -l) key(s) in agent"
        echo "Copying all SSH keys to $user_host..."
    else
        # Find matching keys
        keys_to_copy=$(echo "$available_keys" | grep "$key_pattern")
        if [[ -z "$keys_to_copy" ]]; then
            log_error "No keys found matching pattern '$key_pattern'"
            log_info "Available keys:"
            echo "${available_keys//^/  }"
            return 1
        fi
        
        local key_count
        key_count=$(echo "$keys_to_copy" | wc -l)
        log_info "Found $key_count key(s) matching pattern '$key_pattern'"
        echo "${keys_to_copy//^/  }"
        echo "Copying to $user_host..."
    fi
    
    # Copy keys to remote host
    if echo "$keys_to_copy" | ssh "$user_host" "
      mkdir -p ~/.ssh && 
      chmod 700 ~/.ssh && 
      cat >> ~/.ssh/authorized_keys && 
      chmod 600 ~/.ssh/authorized_keys &&
      echo 'SSH keys successfully added to ~/.ssh/authorized_keys'
    "; then
      log_info "SSH keys copied successfully"
    else
      log_error "Failed to copy SSH keys to $user_host"
      return 1
    fi
}
