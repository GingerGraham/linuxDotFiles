#!/usr/bin/env bash

# Path: .applets
# Purpose: General purpose applets for shell commands
# Use: Add applets to this file and they will be sourced by ~/.applets

# This script adds helper functions to the shell
# It is sourced by .bashrc or .zshrc via ~/.applets
# Define additional functions here

# adding use of website cheat.sh for command lookup
cheat(){
    curl "https://cheat.sh/$1"
}

# Cleanup removed branches in git
git-cleanup() {
    # Fetch updates
    git fetch -p

    # Remove local branches that have been deleted on the remote
    for branch in $(git branch -vv | grep ': gone]' | awk '{print $1}'); do
        log_info "Deleting branch $branch"
        git branch -D "$branch"
    done
}

# Show SSH Tunnel
show-ssh-tunnel(){
  # ps -aux | grep -iE 'ssh\s+(-[fNL]+\s+)*-?[fNL]+'
  pgrep -f 'ssh\s+(-[fNL]+\s+)*-?[fNL]+'
}

# Test sudo access
sudo-test (){
  if [[ ! $(sudo -l -U "${USER}") ]]; then
    log_error "User does not have sudo access"
    return 1
  else
    return 0
  fi
}

detect-package-manager() {
  # Detect the package manager for the current system
  if command -v apt &> /dev/null; then
    PACKAGE_MANAGER="apt"
  elif command -v dnf &> /dev/null; then
    PACKAGE_MANAGER="dnf"
  elif command -v yum &> /dev/null; then
    PACKAGE_MANAGER="yum"
  elif command -v zypper &> /dev/null; then
    PACKAGE_MANAGER="zypper"
  elif command -v pacman &> /dev/null; then
    PACKAGE_MANAGER="pacman"
  elif command -v brew &> /dev/null; then
    PACKAGE_MANAGER="brew"
  else
    log_error "No package manager found"
    return 1
  fi
  log_info "Using package manager: ${PACKAGE_MANAGER}"
  return 0
}

detect-distro () {
  # Detect the Linux distribution
  if [[ -f /etc/os-release ]]; then
    source /etc/os-release
    if [[ -n ${NAME} ]]; then
      OS="${NAME}"
    fi
  fi
  if [[ -z ${OS} ]]; then
    log_error "Unable to detect OS"
    return 1
  fi
  log_info "Detected OS: ${OS}"
  return 0
}

# Single command to update all tools including in this script
update-tools () {
  set_log_format "%m"
  log_info "== Updating Tools =="
  log_info "== Updating AWS CLI =="
  aws-update
  log_info "== Updating Kubectl =="
  set_log_format "%d [%l] [%s] %m"
  log_info " Updating Kubectl to latest version - using set-kubectl -v <version> to set a specific version"
  set_log_format "%m"
  set-kubectl -s
  log_info "== Installing Helm =="
  helm-install
  log_info "== Updating Terraform =="
  terraform-install
  log_info "== Updating Ansible =="
  ansible-install
  set_log_format "%d [%l] [%s] %m"
  return 0
}

# Get the version of GO if installed and save it to an envrioment variable
get-go-version () {
  if [[ -x "$(command -v go)" ]]; then
    GO_VERSION=$(go version | awk '{print $3}'| tr -d 'go')
    export GO_VERSION
  else
    log_error "GO is not installed"
    return 1
  fi
}

get-python-versions () {
  echo "[INFO] Python versions found:"
  for version in /usr/bin/python3*; do
    # Ignore -config directories
    if [[ $version == *-config ]]; then
      continue
    fi
    # Print the base version of python3 such as 3.8, 3.9 etc. and then the full version
    echo "$(basename $version): $($version --version 2>&1)"
  done
}

# Get and return public IPv4 and IPv6 addresses
# Use dig if dig is available, otherwise use curl
get-public-ip () {
  if [[ -x "$(command -v dig)" ]]; then
    echo "IPv4: $(dig -4 TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')"
    echo "IPv6: $(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')"
  else
    echo "IPv4: $(curl -s https://ipv4.icanhazip.com)"
    echo "IPv6: $(curl -s https://ipv6.icanhazip.com)"
  fi
}

open-workspace () {
  if ! command -v code &> /dev/null && ! command -v code-insiders &> /dev/null; then
    log_error "Visual Studio Code is not installed"
    return 1
  fi
  # Accept a directory path as an argument or set ${HOME}/Developement/workspaces as the default
  local workspace_path="${1:-${HOME}/Development/workspaces}"
  local workspaces_full_path=()
  # Check if workspace_path is a symlink and if it is get the full path
  if [[ -L "${workspace_path}" ]]; then
    workspace_path=$(readlink -f "${workspace_path}")
  fi
  # Check if the directory exists and if it does ensure that we have the full valid path
  if [[ -d "${workspace_path}" ]]; then
    if command -v mapfile &> /dev/null; then
      mapfile -t workspaces_full_path < <(find "${workspace_path}" -type f -name "*.code-workspace")
    else
      # shellcheck disable=SC2207
      workspaces_full_path=($(find "${workspace_path}" -type f -name "*.code-workspace"))
    fi
  fi
  # Check if we have any workspaces
  if [[ ${#workspaces_full_path[@]} -eq 0 ]]; then
    log_error "No workspaces found in ${workspace_path}"
    return 1
  fi
  local workspaces=()
  for workspace in "${workspaces_full_path[@]}"; do
    workspaces+=("$(basename "${workspace}" .code-workspace)")
  done
  echo "Available workspaces:"
  PS3="Please select the number of a workspace to open: "
  select workspace in "${workspaces[@]}"; do
    if [[ -n "${workspace}" ]]; then
        for wsp in "${workspaces_full_path[@]}"; do
          if [[ "${workspace}" == "$(basename "${wsp}" .code-workspace)" ]]; then
            if command -v code-insiders &> /dev/null; then
              code-insiders "${wsp}"
            else
              code "${wsp}"
            fi
            break
          fi
        done
      break
    else
      log_error "Invalid selection, try again"
    fi
  done
 }

 # to reregister LUKS key with tpm2 using systemd-crpytenroll
 # Requires the tpm2-tools and dracut tools to be installed
 register-tpm () {
    # Use lsblk with JSON output for easier parsing
    local IFS=$'\n'
    local luks_devices=()
    local partition_device=""
    local enrolled_count=0

    # Check if the required tools are installed
    if ! command -v lsblk &> /dev/null; then
        log_error "Required tools are not installed. Please install lsblk" >&2
        return 1
    fi
    if ! command -v tpm2 &> /dev/null || ! command -v dracut &> /dev/null; then
        log_error "Required tools are not installed. Please install tpm2-tools and dracut" >&2
        return 1
    fi
    if ! command -v cryptsetup &> /dev/null || ! command -v systemd-cryptenroll &> /dev/null; then
        log_error "Required tools are not installed. Please install cryptsetup and systemd-cryptenroll" >&2
        return 1
    fi

    # Check if user has sudo access
    if ! sudo-test; then
        return 1
    fi

    # Process lsblk output to find LUKS partitions
    while read -r line; do
        # Skip header line
        if [[ $line =~ ^NAME ]]; then
            continue
        fi

        # Check if this is a partition line that's followed by a LUKS device
        if [[ $line =~ p[0-9]+[[:space:]] && ! $line =~ crypt ]]; then
            # Extract the partition name, handling the tree structure
            partition_device=$(echo "$line" | awk '{print $1}' | tr -d '└─├─')
            
            # Look at the next line to see if it's a LUKS device
            read -r next_line
            
            if [[ $next_line =~ crypt ]]; then
                device_path="/dev/$partition_device"
                
                if sudo cryptsetup isLuks "$device_path"; then
                    echo "[INFO] Found LUKS encrypted partition: $device_path"
                    luks_devices+=("$device_path")
                fi
            fi
        fi
    done < <(lsblk)

    # Process all found LUKS devices
    for device_path in "${luks_devices[@]}"; do
        echo "[INFO] Enrolling TPM2 for $device_path..."
        if sudo systemd-cryptenroll \
            --wipe-slot=tpm2 \
            --tpm2-device=auto \
            --tpm2-pcrs="0+2+4+5+7" \
            "$device_path"; then
            log_info "Successfully enrolled TPM2 for $device_path"
            ((enrolled_count++))
        else
            log_error "Failed to enroll TPM2 for $device_path" >&2
        fi
    done

    log_info "TPM2 enrollment completed. Successfully enrolled $enrolled_count devices."
    luks_devices=()
    return 0
 }

 get-my-functions () {
  echo
  echo "[INFO] Loaded functions:"
  if [[ -n ${BASH_VERSION} ]]; then
    for func in $(declare -F | awk '{print $3}'); do
      if grep -q "^${func}[[:space:]]*()[[:space:]]*{" "${HOME}/Development/Personal/GitHub/linuxDotFiles/Shell/applets/"*.applets 2>/dev/null; then
        echo "${func}"
      fi
    done | sort | column
  elif [[ -n ${ZSH_VERSION} ]]; then
    grep -Eo '^[a-zA-Z_-][a-zA-Z0-9_-]*\s?\(\)' "${HOME}/applets/"/**/*.applets | sed 's/()//' | awk -F: '{print $NF}' | sort | column
  fi
  echo
  echo "[INFO] Loaded aliases:"
  if [[ -n ${BASH_VERSION} ]]; then
    alias | sed 's/alias //g' | awk -F= '{print $1}' | sort | column
  elif [[ -n ${ZSH_VERSION} ]]; then
    alias -L | sed 's/alias //g' | awk -F= '{print $1}' | sort | column
  fi
 }

list-ssh-hosts() {
  local config_dir="${HOME}/.ssh/config.d"
  local main_config="${HOME}/.ssh/config"
  
  # Process main config file
  echo "=== Main Config ==="
  grep -E "^Host\s" "${main_config}" | sed 's/Host //'
  echo

  # Process each file in config.d
  if [[ -d "$config_dir" ]]; then
      for config_file in "${config_dir}"/*; do
          if [ -f "$config_file" ]; then
              echo "=== $(basename "$config_file") ==="
              grep -E "^Host\s" "$config_file" | sed 's/Host //'
              echo
          fi
      done
  fi
}

install-bitwarden() {
  log_info "Installing or updating Bitwarden password manager..."
  
  # Detect package manager if not already set
  if [[ -z "${PACKAGE_MANAGER}" ]]; then
    detect-package-manager || return 1
  fi
  
  # Check for sudo access if needed for package installation
  if [[ "${PACKAGE_MANAGER}" == "apt" || "${PACKAGE_MANAGER}" == "dnf" || "${PACKAGE_MANAGER}" == "yum" ]]; then
    log_info "Checking sudo access for package installation..."
    if ! sudo-test; then
      log_error "This installation requires sudo access. Please try again with sudo privileges."
      return 1
    fi
  fi
  
  # Create temp directory for downloads
  local temp_dir=$(mktemp -d)
  log_debug "Created temporary directory: ${temp_dir}"
  
  # Install based on detected package manager
  case "${PACKAGE_MANAGER}" in
    apt)
      log_info "Using APT package manager - installing DEB package"
      local deb_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=deb"
      local deb_file="${temp_dir}/bitwarden.deb"
      
      # Download the DEB package
      log_info "Downloading Bitwarden DEB package..."
      if ! curl -L -o "${deb_file}" "${deb_url}"; then
        log_error "Failed to download Bitwarden DEB package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the DEB package
      log_info "Installing Bitwarden..."
      if ! sudo dpkg -i "${deb_file}"; then
        log_error "Failed to install Bitwarden DEB package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Fix any dependency issues
      log_info "Resolving dependencies..."
      sudo apt-get install -f -y
      ;;
      
    dnf|yum)
      log_info "Using ${PACKAGE_MANAGER} package manager - installing RPM package"
      local rpm_url="https://bitwarden.com/download/?app=desktop&platform=linux&variant=rpm"
      local rpm_file="${temp_dir}/bitwarden.rpm"
      
      # Download the RPM package
      log_info "Downloading Bitwarden RPM package..."
      if ! curl -L -o "${rpm_file}" "${rpm_url}"; then
        log_error "Failed to download Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      
      # Install the RPM package
      log_info "Installing Bitwarden..."
      if ! sudo "${PACKAGE_MANAGER}" install -y "${rpm_file}"; then
        log_error "Failed to install Bitwarden RPM package"
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
      
    *)
      # Try flatpak as a fallback
      if command -v flatpak &> /dev/null; then
        log_warn "Native package not available for ${PACKAGE_MANAGER}. Using Flatpak instead."
        
        # Add Flathub repository if not already added
        if ! flatpak remotes | grep -q "flathub"; then
          log_info "Adding Flathub repository..."
          flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        fi
        
        # Install Bitwarden flatpak
        log_info "Installing Bitwarden via Flatpak..."
        if ! flatpak install -y flathub com.bitwarden.desktop; then
          log_error "Failed to install Bitwarden via Flatpak"
          rm -rf "${temp_dir}"
          return 1
        fi
      else
        log_error "No supported package manager found. Please install Bitwarden manually."
        log_info "Visit https://bitwarden.com/download/ for installation options."
        rm -rf "${temp_dir}"
        return 1
      fi
      ;;
  esac
  
  # Clean up
  log_debug "Cleaning up temporary files"
  rm -rf "${temp_dir}"
  
  log_info "Bitwarden installation completed successfully!"
  return 0
}