#!/bin/bash

# This script adds helper functions to the shell
# It is sourced by .zshrc
# Define additional functions here

# Update AWS CLI
aws-update () {
  echo "Download AWS CLI"
  cd /tmp || return
  curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  echo "AWS CLI downloaded"
  echo "Unzipping"
  unzip awscliv2.zip
  echo "Unzipped"
  echo "Installing"
  sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
  echo "Installed"
  echo "Cleaning up"
  rm -rf ./awscliv2.zip ./aws
  cd - || return
  echo "Completed"
}

# Use ansible-vault to decrypt a list of file
avd () {
  # Check if variables are already set and if so unset -f
  if [[ -v VAULT_PASS ]]; then
    VAULT_PASS=""
  fi
  if [[ -v FILES ]]; then
    FILES=()
  fi
  # Check if ansible is installed
  if ! command -v ansible &> /dev/null
  then
      echo "Ansible could not be found"
      return 1
  fi
  # Use getopts to parse the arguments
  while getopts ":p:" opt; do
    case $opt in
      p) VAULT_PASS="$OPTARG"
         echo "Pass file is ${VAULT_PASS}" >&2
      ;;
      \?) echo "Invalid option -$OPTARG" >&2
          return 1
      ;;
    esac
  done

  # Process arguments excluding arguments passed as options
  shift $((OPTIND -1))
  echo "Processing ${*}"
  # If argument in $@ is not a switch or existing variable add it to an array of file names
  for arg in "${@}"; do
    if [[ ! $arg =~ ^-.* ]] || [[ ! -v $arg ]]; then
      # echo "adding $arg to FILES"
      FILES+=("$arg")
    fi
  done

  # If FILES is empty then report an error and return
  if [[ -z ${FILES[*]} ]]; then
    echo "No files to decrypt"
    return 1
  fi

  # Test if ansible.cfg exists and if vault_password_file is set, then test if the value for vault_password_file exists in the current directory.  If it does run ansible-vault decrypt without using the VAULT_PASS or prompting for a password
  if [[ -f "ansible.cfg" ]]; then
    if grep -q "vault_password_file" "ansible.cfg"; then
      if [[ -f "$(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')" ]]; then
        echo "Decrypting ${FILES[*]} with password file: $(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')"
        for file in "${FILES[@]}"; do
          # echo the command to be run
          # echo "ansible-vault decrypt ${file}"
          ansible-vault decrypt "${file}"
        done
        return 0
      fi
    fi
  fi

  # Check if the vault password file exists
  if [[ ! -f "${VAULT_PASS}" ]]; then
    echo "Vault password file does not exist"
    # Remove VAULT_PASS from the environment
    VAULT_PASS=""
  fi

  if [[ ! -z "${VAULT_PASS}" ]]; then
    echo "Decrypting ${FILES[@]} with password file: ${VAULT_PASS}"
    for file in "${FILES[@]}"; do
      ansible-vault decrypt --vault-password-file "${VAULT_PASS}" "${file}"
    done
  else
    echo "Prompting for password to decrypt ${FILES[@]}"
    for file in "${FILES[@]}"; do
      ansible-vault decrypt "${file}"
    done
  fi

  # Remove all variables
  FILES=()
  VAULT_PASS=""
}

# Use ansible-vault to encrypt a list of file
ave () {
  # Check if variables are already set and if so unset -f
  if [[ -v VAULT_PASS ]]; then
    VAULT_PASS=""
  fi
  if [[ -v FILES ]]; then
    FILES=()
  fi
  # Check if ansible is installed
  if ! command -v ansible &> /dev/null
  then
      echo "Ansible could not be found"
      return 1
  fi
  # Use getopts to parse the arguments
  while getopts ":p:" opt; do
    case $opt in
      p) VAULT_PASS="$OPTARG"
         echo "Pass file is ${VAULT_PASS}" >&2
      ;;
      \?) echo "Invalid option -$OPTARG" >&2
          return 1
      ;;
    esac
  done

  # Process arguments excluding arguments passed as options
  shift $((OPTIND -1))
  echo "Processing ${@}"
  # If argument in $@ is not a switch or existing variable add it to an array of file names
  for arg in "${@}"; do
    if [[ ! $arg =~ ^-.* ]] || [[ ! -v $arg ]]; then
      echo "adding $arg to FILES"
      FILES+=("$arg")
    fi
  done

  # If FILES is empty then report an error and return
  if [[ -z ${FILES[*]} ]]; then
    echo "No files to encrypt"
    return 1
  fi

  # Test if ansible.cfg exists and if vault_password_file is set, then test if the value for vault_password_file exists in the current directory.  If it does run ansible-vault encrypt without using the VAULT_PASS or prompting for a password
  if [[ -f "ansible.cfg" ]]; then
    if grep -q "vault_password_file" "ansible.cfg"; then
      if [[ -f "$(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')" ]]; then
        echo "Encrypting ${FILES[*]} with password file: $(grep "vault_password_file" "ansible.cfg" | cut -d'=' -f2 | tr -d ' ')"
        for file in "${FILES[@]}"; do
          # echo the command to be run
          # echo "ansible-vault encrypt ${file}"
          ansible-vault encrypt "${file}"
        done
        return 0
      fi
    fi
  fi

  # Check if the vault password file exists
  if [[ ! -f "${VAULT_PASS}" ]]; then
    echo "Vault password file does not exist"
    # Remove VAULT_PASS from the environment
    VAULT_PASS=""
  fi

  if [[ ! -z "${VAULT_PASS}" ]]; then
    echo "Encrypting ${FILES[@]} with password file: ${VAULT_PASS}"
    for file in "${FILES[@]}"; do
      ansible-vault encrypt --vault-password-file "${VAULT_PASS}" "${file}"
    done
  else
    echo "Prompting for password to encrypt ${FILES[@]}"
    for file in "${FILES[@]}"; do
      ansible-vault encrypt "${file}"
    done
  fi

  # Remove all variables
  FILES=()
  VAULT_PASS=""
}

# Function to set a specific version of kubectl for the current shell and if it is not already installed download it
set_kubectl () {
  # Check if variables are already set and if so unset -f
  if [[ -v KUBECTL_VERSION ]]; then
    KUBECTL_VERSION=""
  fi
  if [[ -v USE_LATEST ]]; then
    USE_LATEST=""
  fi
  # Use getopts to parse the arguments
  while getopts ":hlsv:" opt; do
    case $opt in
      h) echo "Usage: set_kubectl [-v version]"
         echo "  -v version  The version of kubectl to use"
         return 0
      ;;
      l|s) # set the version of kubectl to the USE_LATEST version
         USE_LATEST=true
      ;;
      v) KUBECTL_VERSION="$OPTARG"
      ;;
      \?) echo "Invalid option -$OPTARG" >&2
          return 1
      ;;
      *) PARAMS="$PARAMS -$OPTARG"
      ;;
    esac
  done
  # If USE_LATEST is set to true then get the USE_LATEST version of kubectl
  if [[ "${USE_LATEST}" == "true" ]]; then
    echo "-l or -s is set"
    echo "Getting latest stable version of kubectl from https://storage.googleapis.com/kubernetes-release/release/stable.txt and ignoring any version passed"
    KUBECTL_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
    # remove the v from the version
    KUBECTL_VERSION="${KUBECTL_VERSION:1}"
  fi
  # If KUBECTL_VERSION is not set then use the first argument
  if [[ -z "${KUBECTL_VERSION}" ]]; then
    KUBECTL_VERSION="${1}"
  fi
  # Check the passed value is a valid version
  if [[ ! "${KUBECTL_VERSION}" =~ ^[0-9]\.[0-9]+\.[0-9]+$ ]]; then
    echo "Invalid version of kubectl specified: ${KUBECTL_VERSION}"
    # If version passed is missing the patch version then add it as 0
    if [[ "${KUBECTL_VERSION}" =~ ^[0-9]\.[0-9]+$ ]]; then
      echo "Adding patch version of 0 to ${KUBECTL_VERSION}"
      KUBECTL_VERSION="${KUBECTL_VERSION}.0"
    else
      return 1
    fi
  fi
  # If KUBECTL_VERSION is still not set then report an error and return
  if [[ -z "${KUBECTL_VERSION}" ]]; then
    echo "No version of kubectl specified"
    return 1
  fi
  # Confirm the version is set back to the user
  echo "Taking ${KUBECTL_VERSION} as the version of kubectl to use"
  # Check if kubectl is already installed and if the current version matches the version to be set
  # Using kubeclt version --client --short to get the version as it is faster than using kubectl version --short
  if command -v kubectl &> /dev/null; then
    if [[ "$(kubectl version --client --short | grep -oP '(?<=Client Version: v)[0-9]\.[0-9]+\.[0-9]+')" == "${KUBECTL_VERSION}" ]]; then
      echo "kubectl is already installed and is the correct version"
      return 0
    fi
  fi
  # Setting the directory to download kubectl to
  KUBECTL_DIR="${HOME}/.local/bin/k8s/kubectl-${KUBECTL_VERSION}"
  # Check if the directory exists and if not create it
  if [[ ! -d "${KUBECTL_DIR}" ]]; then
    mkdir -p "${KUBECTL_DIR}"
  fi
  # Check the OS and set the download URL
  if [[ "$(uname)" == "Darwin" ]]; then
    KUBECTL_URL="https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/darwin/amd64/kubectl"
  elif [[ "$(uname)" == "Linux" ]]; then
    KUBECTL_URL="https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
  else
    echo "Unsupported OS"
    return 1
  fi
  # Check if the requested version is available in the directory and if not download it
  if [[ ! -f "${KUBECTL_DIR}/kubectl" ]]; then
    echo "Downloading kubectl-${KUBECTL_VERSION}"
    curl -s -L "${KUBECTL_URL}" -o "${KUBECTL_DIR}/kubectl"
    chmod +x "${KUBECTL_DIR}/kubectl"
  fi
  # Check that the version downloaded is available executable and if it report and error and exit
  if [[ ! -x "${KUBECTL_DIR}/kubectl" ]]; then
    echo "Error downloading kubectl v${KUBECTL_VERSION}"
    echo "Please check the version is valid and try again"
    return 1
  fi
  echo "kubectl v${KUBECTL_VERSION} downloaded to ${KUBECTL_DIR}"
  # Check if the current version of kubectl is a symlink and if so remove it
  if [[ -L "$(command -v kubectl)" ]]; then
    echo "Removing symlink to kubectl"
    rm "$(command -v kubectl)"
  fi
  # If current version of kubectl is not a symlink then rename it to kubectl.old
  if command -v kubectl &> /dev/null; then
    echo "Renaming current version of kubectl (located at $(command -v kubectl)) to kubectl.old"
    mv "$(command -v kubectl)" "$(command -v kubectl).old"
    echo "If a permission error is reported then run the following command with sudo"
    echo "sudo mv $(command -v kubectl) $(command -v kubectl).old"
    echo "If you wish to revert to the previous version of kubectl then run the following command:"
    echo "mv $(command -v kubectl).old $(command -v kubectl)"
  fi
  # Create a symlink to the requested version of kubectl
  echo "Creating symlink to ${KUBECTL_VERSION} located at ${KUBECTL_DIR}/kubectl"
  ln -s "${KUBECTL_DIR}/kubectl" "${HOME}/.local/bin/kubectl"
  return 0
}